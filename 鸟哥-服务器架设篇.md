> **鸟哥的**Linux私房菜-服务器架设篇



# 第2章 网络基本概念

![第2章 网络的基础概念](http://s.i9u.cc/%E7%AC%AC2%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png)

## 2.1 网络

### OSI 七层协议

> 将整个网络连接过程分成数个层次(layer),每个层次都有特定独立的功能,而且每个层次的程序代码可以独立编写,因为每个层次之间的功能并不会互相干扰.
>
> OSI 七层协议(Open System Interconnection)

![OSI七层协议](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_layer_to_layer.gif)



越接近硬件的阶层为底层(layer 1)，越接近应用程序的则是高层(layer 7).**不论是接收端还是发送端,每个层次只认识对方的同一层次的数据**

在七层协议中，每层都会有自己独特的头部数据(header)，告知对方这里边的信息是什么，而真正的数据就附在后头。

上层的包裹是放入下层的数据中，而数据前面则是这个数据的报头。

==第二层(数据链路层)比较特殊==,因为 **数据链路层** 位于软件包(packet)以及硬件数据帧(frame)中间的一个阶层，它必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个层次又分为两个子层来处理相对应的数据。

因为比较特殊，所以，第二层的数据格式比较不一样，尾端出现了一个检查码。

**物数网传输，会话表应用**



![物数网传输会话表应用](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_packet.gif)



| 分层              | 负责内容                                                     |
| ----------------- | ------------------------------------------------------------ |
| layer1 物理层     | 定义所使用的传输设备的电压与信号                             |
| layer2 数据链路层 | 偏软件部分：逻辑链路层控制，把上层数据包转成MAC格式<br />偏硬件部分：MAC数据帧，被物理层编码成比特流的数据 |
| layer3 网络层     | IP(Internet Protocol) 计算机之间 连接的建立、终止与维持  和 路由 route |
| layer4 传输层     | 发送端与接收端的连接技术(TCP、UDP) 数据包格式、数据包发送、传输是否送达并重发<br />**判断数据包是否可以正确的到达目标** 三次握手在TCP上 |
| layer5 会话层     | 网络管理、建立与断开、会话控制<br />**确定网络服务建立连接的确认** |
| layer6 表示层     | 本地端应用程序的数据格式转换为网络的标准格式<br />网络服务之间的数据格式的转换，包括 **数据的加解密** |
| layer7 应用层     | 定义应用程序如何进入该层的沟通接口，以及将数据接收或发送给应用程序 |



### TCP/IP 网络协议

**TCP/IP 通信协议**

TCP/IP 是在 OSI 七层协议的观念上，同样具有分层的架构，只是将它简化为四层。

![](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_tcpip.gif)



TCP/IP 将应用、表示、会话三层整合成一个应用层。

传输层没有变，不过依据 **传送的可靠性** 将封包格式分为 **面向连接的TCP** 和 **无连接的UDP**。

网络层没有变，主要内容是提供 IP 数据包，并可选择最佳路由来到达目标IP地址。

数据链路层与物理层则整合为一个网络接口层，包括定义硬件信号、数据帧转换为比特流的编码等，因此主要与硬件有关



---

:question: TCP/IP 如何工作？打开 Yahoo 网站

* 应用程序阶段：浏览器地址栏输入网址，回车。此时网址信息与相关数据被浏览器包成一个数据，向下传给 TCP/IP 的应用层。

* 应用层：由应用层提供 HTTP 通信协议，将来自浏览器的数据封装起来，并给予一个应用层报头，向传输层丢去
* 传输层：由于 HTTP 为可靠连接，因此数据进入 TCP 封装内，并给予一个 TCP 封包的报头，向网络层丢去
* 网络层：将 TCP 数据封装到 IP 数据包内，再给予一个 IP 包头(主要就是来源与目标的IP)，向网络接口层丢去
* 网络接口层：使用以太网络，IP 依据 CSMA/CD 的标准，封装到 MAC 数据帧中，并给予 MAC 帧头，再转成比特流后，利用传输介质发送到远程主机上



网络介质一次传输的数据量是有限的，因此如果被传输的数据太大时，我们在各层的封装中，就需要将数据先拆开放到不同的数据包中，再给数据包一个序号，好让目标端的主机能够利用这些序号再重新将数据整合回来。



> 接下来我们介绍的顺序是：TCP/IP的网络接口层、网络层、传输层来进行说明.
>
> TCP/IP中的应用层为`用户层`,底下的三层是我们谈及的`网络基础`



## 2.2 网络接口层

TCP/IP 最底层的 网络接口层 主要与硬件的关系比较密切。

广域网使用的设备：电话拨号、ADSL、电缆

局域网使用的设备：以太网



:question: 2M/128Kbps 为什么？

### 以太网络的传输协议：CSMA/CD

> 以太网的传输主要是 网卡对网卡的数据传递
>
> 每张以太网卡出厂时,会赋予一个独一无二的卡号，就是 MAC（Media Access Control）



![CSMA/CD连接](http://cn.linux.vbird.org/linux_server/0110network_basic_files/csmacd.gif)



集线器 是一种 **网络共享** 介质设备。网络共享介质在单一时间点内，仅能被一台主机所使用。

:point_right: 模拟 A发送到D 的流程

* 监听介质使用情况：A主机发送数据包前，先对网络介质进行监听,确定没人使用，再发送数据包
* 多点传输：A主机发送的数据会被集线器复制一份，然后发送给所有连接此集线器的主机。A发送出去的数据，B、C、D三部计算机都能够接收到，但由于目标是D主机，所以B与C会将数据帧丢掉，而D会抓下来处理
* 冲突检测：该数据帧有检测能力，若其他主机B在同时间内发送，则A与B的数据冲突，此时数据都被销毁，A与B各自随机等待一个时间，重新发送



交换器 Switch 是 **非共享的设备**，与集线器最大的差异，在于交换器内有一个特别的内存，整个内存可以记录每个 交换器port 与其连接的 PC 的 MAC 地址。

当来自 Switch 两端的PC要互传数据时，每个数据帧将直接通过交换器的内存数据而传送到目标主机上。



### MAC 的封装格式

上面提到的 CSMA/CD 发送出去的数据帧，其实就是 MAC。这个数据帧上有两个重要的数据，就是目标与来源的网卡卡号，因此简称网卡卡号为 MAC 地址。

MAC 是整个网络硬件上面传送数据的最小单位

Linux下可以使用 `ifconfig` 命令查看网卡卡号。

在这个 MAC 的传送中，仅在局域网络内生效，如果跨过不同的子网，那么来源与目的的硬件地址就会跟着改变了。因为变成不同网卡之间的交流了，所以卡号当然不同。



### 集线器、交换机与相关机制

交换器(Switch)与集线器(Hub)最大的差异:交换机内有一个特别的内存，这个内存可以记录每个 Switch port 与其连接的 PC 的 MAC 地址。所以 Switch 不是共享设备，每个数据帧都将通过交换器的内存数据而直接传送到目标主机上。

## 2.3 网络层

有网络就必须要有网络相关的硬件，最常见的网络硬件接口为 **以太网**，包括网线、网卡、Hub/Switch 等



### IP数据包的封装

![image-20190119225029579](http://markdown.icron.cc/image-20190119225029579.png)

IP有两个版本，一个是 IPV4，一种是 IPV6

IPV4 记录的地址仅有 32 位，预计2020年前后分配完毕。IPV6的地址可以达到 128 位，多出 2 的 96 次方



Time To Live（TTL 生存时间）

表示这个 IP 数据包的生存时间，范围为0～255 当这个IP数据包通过一个路由器时，TTL就减1，当TTL为0时，这个数据包将会直接丢弃。

:question: 网络解析的ttl 有什么用？

ttl 就是一条域名解析记录在DNS服务器中的存留时间。

TTL 就是 Time-to-live 的缩写，用来表明域名和IP对应关系在多长时间内有效，过了有效期就要重新去查询。

TTL 时间越长，缓存时间越长，更新越不容易及时生效。适合长度不更换，加快解析速度。

TTL 设置的小一些，生效时间就快一些，换空间的时候更合适。

[域名解析设置TTL多少合适?]: http://hizip.net/index.php/archives/20/



### IP地址的组成和分级

#### IP的组成

> IP是一种网络数据包，这个数据包的报头最重要的就是 那个32位的来源地址与目标地址

```bash
IP 的表示式：
00000000.00000000.00000000.00000000   ==> 0.0.0.0
11111111.11111111.11111111.11111111   ==> 255.255.255.255

#还可以分为两部分：Net_ID网络号码 与 Host_ID主机号码
192.168.0.0~192.168.0.255 这个 Class C 的说明：
11000000.10101000.00000000.00000000
11000000.10101000.00000000.11111111
|----------Net_ID---------|-host--|
```

前边的三组数字(192.168.0)就是网络号码，最后面一组数字为主机号码。

同一个网络：在同一个物理网段内，主机的IP具有相同的Net_ID，并且具有独特的Host_ID



在同一个网段内，Net_ID 是不变的，而  Host_ID 是不可重复的。

Host_ID全为0表示整个网段的地址(Network IP)，全为1表示广播的地址(Broadcast IP)   NB牛逼来记忆



#### IP的分级

将整个IP网段分为五种等级

```bash
以二进制说明 Network 第一个数字的定义：
Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 0
          |--net--|---------host------------|
Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 10
          |------net-------|------host------|
Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 110
          |-----------net-----------|-host--|
Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1110
Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1111

五种分级在十进制的表示：
Class A :   0.xx.xx.xx ~ 127.xx.xx.xx
Class B : 128.xx.xx.xx ~ 191.xx.xx.xx
Class C : 192.xx.xx.xx ~ 223.xx.xx.xx
Class D : 224.xx.xx.xx ~ 239.xx.xx.xx
Class E : 240.xx.xx.xx ~ 255.xx.xx.xx
```



### IP的种类

* Public IP：公共IP
* Private IP：私有IP或保留IP，不能直接联网，用于局域网络内的主机连接规划



私有IP网段

- Class A：10.0.0.0    - 10.255.255.255
- Class B：172.16.0.0  - 172.31.255.255
- Class C：192.168.0.0 - 192.168.255.255

**使用私有IP作为来源或目的地址的数据包，不能通过 Internet 来传送。通过 CSMA/CD 的功能在局域网进行广播，亦可以直接网卡对网卡传递数据(通过MAC数据帧)**



还有一个奇怪的 Class A的网络，为 lo 网络，被用来作为测试操作系统内部循环所用的一个网络，同时也能够提供给系统内部原本就需要使用网络接口的服务daemon所使用

127.0.0.0/8 这个 Class A，默认的主机(localhost)的IP是127.0.0.1



### Netmask、子网与CIDR

Class A 的网段有 256x256x(256-2) 这么多IP，回想 CSMA/CD，对所有计算机进行广播，会很卡顿。所以分成多个局域网，再来规划每个局域网内的计算机。总之，让 Class A 网段变小，将网络切的更细。

让 Class A 网段变小，将网络切的更细。

IP 有32位数值分为 网络号码与主机号码。以 Class C 为例，网络号占了 24 位，让第一个 Host_ID 当作 Net_ID，这样 Net_ID 就有 25 bits，Host_ID则为 7 bits。这样原来的 Class C 的网络被划分为**两个子局域网**，每个子局域网有 256/2-2 = 126 个可用IP



#### Netmask

或称为 Subnet mask 子网掩码。

这个IP网段可以分为 Net_ID 与 Host_ID ，既然 Net_ID 不可变，那就假设它占据的位已经用完（全部为1），而Host_ID是可变的，将它想成是保留值(全部为0),所以 Netmask 的表示为：

```php
192.168.0.0~192.168.0.255 这个 C Class 的 Netmask 说明
第一个 IP： 11000000.10101000.00000000.00000000
最后一个 ： 11000000.10101000.00000000.11111111
            |----------Net_ID---------|-host--|
Netmask  ： 11111111.11111111.11111111.00000000  <== Netmask 二进制
         ：   255   .  255   .  255   .   0      <== Netmask 十进制
特别注意喔，netmask 也是 32 位，在数值上，位于 Net_ID 的为 1 而 Host_ID 为 0
```

```php
Class A, B, C 三个等级的 Netmask 表示方式：
Class A : 11111111.00000000.00000000.00000000 ==> 255.  0.  0.  0
Class B : 11111111.11111111.00000000.00000000 ==> 255.255.  0.  0
Class C : 11111111.11111111.11111111.00000000 ==> 255.255.255.  0
```

```php
//192.168.0.1~192.168.0.255 这个 Class C 网络中,Netmask为255.255.255.0
Netmask:   255.255.255.0   <==网络定义中，最重要的参数
Network:   192.168.0.0     <==第一个 IP
Broadcast: 192.168.0.255   <==最后一个 IP
可用以设定成为主机的 IP 数：
192.168.0.1 ~ 192.168.0.254
```



#### 子网划分

Class C 可以继续分为子网(Subnet)的划分，如果 Net_ID 使用了25bits时

```php
原本的 C Class 的 Net_ID 与 Host_ID 的分别
11000000.10101000.00000000.00000000      Network:   192.168.0.0
11000000.10101000.00000000.11111111      Broadcast: 192.168.0.255
|----------Net_ID---------|-host--|

切成两个子网之后的 Net_ID 与 Host_ID 为何？
11000000.10101000.00000000.0 0000000  多了一个 Net_ID 了, 为 0 (第一个子网)
11000000.10101000.00000000.1 0000000  多了一个 Net_ID 了, 为 1 (第二个子网)
|----------Net_ID-----------|-host--|

第一个子网
Network:   11000000.10101000.00000000.0 0000000   192.168.0.0
Broadcast: 11000000.10101000.00000000.0 1111111   192.168.0.127
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128

第二个子网
Network:   11000000.10101000.00000000.1 0000000   192.168.0.128
Broadcast: 11000000.10101000.00000000.1 1111111   192.168.0.255
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128
```



---

192.168.0.0 ~ 192.168.0.255 这个网段，给予 Net_ID 是26位，分为几段？

26 - 24 = 2 用掉两个位，2的2次方，得到4个网段，再将256个IP平均分配到4个网段

```php
- 192.168.0.0~192.168.0.63            =>  192.168.0.0/26
- 192.168.0.64~192.168.0.127          =>  192.168.0.64/26
- 192.168.0.128~192.168.0.191         =>  192.168.0.128/26
- 192.168.0.192~192.168.0.255         =>  192.168.0.192/26

#用 >> 运算也可以 2>2=4    
```





#### 无类别域间路由 CIDR

> 将很多小网络合并为一个大网络。和netmask相反

```php
Network/Netmask
192.168.0.0/255.255.255.0
192.168.0.0/24    <==因为 Net_ID 共有 24 个 bits
```

**此处 `24` 为 Net_ID 的位数**

* classA  8
* classB  16
* classC  24



```php
// 将 Net_ID 借用来作为 Host_ID,可以将多个网络写成一个
192.168.0.0/16    //这样Class C变成了 Class B  打破原本IP等级的方式称为无类别域间路由 CIDR
```



[子网掩码计算器]: http://tool.chinaz.com/Tools/subnetmask





### 路由概念

同一个局域网里边，可以通过 IP 广播的方式实现数据传递。非局域网，需要使用路由器。



:question: 什么是同一个网络呢？

Network 以及 Netmask 来表示一个网络。同一网络的意思是 Network 相同，在同一个网段中。



两台客户机之间传递数据，通过 Net_ID 来知道是否在同一个网段内，每台主机都有自己的 “路由表”。



![路由表](http://cn.linux.vbird.org/linux_server/0110network_basic_files/route_1.jpg)



1) 查询IP数据包的目标IP地址

2) 查询是否位于本机所在的网络路由表中，如果是，直接通过局域网功能，将数据传送给目的地主机

3) 查询默认路由器(Default Gateway) 

4) 送出数据包至 Default Gateway 后，不理会数据包流向



每台主机里边都存在一个路由表，数据的传递将依据这个路由表进行传送。一旦数据包已经由路由表的路由条目发送出去后，那么主机本身就已经不再管数据包的流向了，因为该数据包的流向将是下一台主机来进行传送。

​	

**数据来了，先查自己的路由表。如果在同一个网络(Net_ID相同,Host_ID不同)里，IP广播的形式MAC to MAC进行传递。如果不在一个网络里，则直接发送给默认路由器(Default Gateway)**

### 路由表

路由一旦设置错误，造成某些数据包无法正确的送出去。

每台主机都有自己的路由表，命令是 Route 

```bash
route [-n]
-n: 将主机名以 IP 的方式显示

> route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    0      0        0 eth0
link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0

> route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.21.0.1      0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0
```

几乎每一台主机都会有一个 Default Gateway 来负责所有非局域网络内的数据包传递。



🐸 网络层主要是进行数据的传递。每台主机有自己的路由表，当数据传递过来时，查询路由表，看是不是在同一个局域网，如果目标IP在同一个局域网，则直接进行传递；如果不在同一个局域网，则把数据发送给路由表的 default gateway。可以通过 ping 和 traceroute 来检查网络的状态。

网络层的IP数据包只负责将数据传送到正确的目标主机去。

## 2.4 传输层

网络层的 IP 数据包 只负责将数据送到正确的目标主机去，对于数据包到底会不会被接受，或者是有没有被正确接收，是传输层的任务之一。

> 面向连接的 TCP 数据包
>
> 无连接的 UDP 数据包



### 面向连接的可靠的 TCP 协议

TCP 数据包 包含以下

1) Source Port & Destination Port 源端口 & 目标端口

2) Sequence Number 数据包序号

​    当TCP数据太大时，需要分段。记录每个数据包的序号，让接收端按照序号重新组合

3) Acknowledge Number 回应序号

​    确认主机端确实收到了我们发送的数据包。当 Client 端收到这个确认码时，能确定传递的数据包被正确收下了

4) Data Offset 数据补偿

5) Reserved 保留

6) Code (Control Flag 控制标志码)

​    进行网络连接的时候，必须要说明这个连接的状态，好让接收端了解这个数据包的主要动作

​    URG

​    ACK(Acknowledge) 为1表示这个数据包为响应数据包，当 Client 端接收到这个确认码时，就能确定之前传递的数据包已经被正确收下了。

​    PSH

​    RST(Reset) 为1表示连接会被马上结束，无需等待终止确认手续。强制结束，发送端已断线

​    SYN(Synchronous) 为1表示发送端希望双方建立同步处理,也就是要求建立连接。SYN标志的数据包表示“主动”要连接对方的意思。

​    FIN(Finish) 为1表示传送结束，通知对方数据传毕，是否同意断线，只是发送者还在等待对方的响应而已。

7) Window (滑动窗口)

8) Checksum (确认校验码) 检测发送端的数据是否完整

9) Urgent Point (紧急数据)

10) Options (任意数据)

11) Padding (补足字段)



TCP 报头数据中，最重要的是 来源与目标的端口。

Linux 环境下，各网络服务与 port number 的对应默认写在 `/etc/services` 文件内

小于1024以下的端口要启动时，启动者的身份必须是 root 才行，所以叫特权端口。



### TCP 的三次握手

TCP 称为 可靠的数据传输协议，最重要的就是三次握手。



![三次握手](http://cn.linux.vbird.org/linux_server/0110network_basic_files/3_hand_shak.png)







A：数据包发起

客户端发起一个要求连接的数据包，在TCP的报头重，带有 SYN 的主动连接(SYN=1)，记录下数据包的序号(Sequence number = 10001)



B：数据包接收与确认数据包传送

当服务器接到这个数据包，并且确定要接收这个数据包后，制作一个同时带有 SYN=1,ACK=1 的数据包

其中 Acknowledge 的号码是给 Client 端确认用的，所以比 A步骤里的 Sequence 号码多一号(ack = 10001 + 1 = 10002)，我们的服务器也必须要确认客户端确实可以接收我们的数据包才行，所以也会发送一个 Sequence(seq = 20001) 给客户端，并且开始等待客户端给我们服务器端的回应。



C：回送确认数据包

当客户端收到来自服务器端的 ACK 数字后(10002)，就能够确认之前那个要求数据包被正确接收了，接下来如果客户端也同意与服务器端建立连接时，就会再次发送一个确认数据包(ACK=1)给服务器，即 Acknowledge = 20001 + 1 = 20002



D：取得最后确认

若一切顺利，在服务器端接收到带有 ACK=1 且 ack=20002 序号的数据包后，就能够建立起这次的连接了。



---

A：在不在？

B：在呢，你在不在

A：我也在

---



### 无连接的 UDP 协议

UDP 的全称是 User Datagram Protocol 用户数据报协议

UDP 不提供可靠的传送模式，因为它不是面向连接的机制，在 UDP 的传送过程中，接收端在接收到数据包之后，不会回复响应数据包(ACK)给发送端。

UDP 不需要确认对方是否正确的收到数据，可以比 TCP 更快速，通常用在 实时传送软件上，对数据的完整性没有精确需求的场景上。

**UDP 通信协议由于不需要连接确认，因此适用于快速实时传输且不需要数据可靠的软件中，例如实时通信。**



### 网络防火墙与OSI七层协议

利用防火墙机制与软件来进行数据包报头的分析，并且设定分析的规则，当发现某些特定的IP、特定的端口或者是特定的数据包信息(SYN/ACK等)，就将数据包丢弃，这就是基本的防火墙原理



第二层(数据链路层)：针对来源于目标的 MAC 进行阻挡

第三层(网络层)：针对来源于目标的 IP，以及 ICMP 的类别(type) 进行阻挡

第四层(传输层)：针对 TCP/UDP 的端口进行阻挡，也可以针对 TCP 的状态 (code) 来处理



在 Linux 中，DNS 主机IP的设定在 /etc/resolv.conf

DNS 的主要目的 在于进行 Host Name 与对应的 IP 的解析功能。

# 第3章 局域网架构简介

局域网布线规划

网络设备选购建议



# 第4章 连接 Internet

```bash
#确认网卡被内核捕捉到
dmesg | grep -in eth

#查看网卡卡号
ifconfig eth0
```





```bash
#配置ip
> ifconfig eth0 192.168.1.100
> ifconfig

#ip设置好之后，利用ping指令来ping一下局域网内的其他计算机，如果有响应，则网卡配置好了
```



## 4.1 网络相关配置文件

| 所需网络参数                    | 主要配置文件档名                          | 重要参数                                                     |
| ------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| IP Netmask DHCP 与否 Gateway 等 | /etc/sysconfig/network-scripts/ifcfg-eth0 | DEVICE=网卡的名称 <br />BOOTPROTO=是否使用 dhcp <br />HWADDR=是否加入网卡(MAC) <br />IPADDR=就是IP地址 <br />NETMASK=子网掩码 <br />ONBOOT=要不要默认启动此接口 <br />GATEWAY=网关地址 <br />NM_CONTROLLED=额外的网管软件 <br />鸟哥建议取消这个项目！ |
| 主机名                          | /etc/sysconfig/network                    | NETWORKING=要不要有网络 <br />NETWORKING_IPV6=支持IPv6否<br /> HOSTNAME=你的主机名 |
| DNS IP                          | /etc/resolv.conf                          | nameserver DNS的IP                                           |
| 私有 IP 对应 的主机名           | /etc/hosts                                | 私有IP 主机名 别名                                           |

 

还有如下文件

* /etc/services

  记录 TCP/IP 上的各种协议，包括 HTTP、FTP、SSH、Telnet 等服务定义的 port number，都是这个文件规划出来的

* /etc/protocols

  定义 IP 数据包协议的相关数据，包括 ICMP/TCP/UDP 的数据包协议的定义等



网络方面的启动命令如下

```bash
#重新启动整个网络的参数。会主动去读取所有的网络配置文件
/etc/init.d/network restart

#启动或关闭某个网络接口,会去 /etc/sysconfig/network-scripts/ 目录下,读取适当的配置文件来处理
ifup eth0 (ifdown eth0)
```



## 4.2 连接 Internet 设置方法

### 4.2.1 手动配置固定IP参数

| 修改的参数 | 配置文件与重要启动脚本                                       | 观察结果的指令                                        |
| ---------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| IP相关参数 | /etc/sysconfig/network-scripts/ifcfg-eth0 <br />/etc/init.d/network restart | ifconfig (IP/Netmask) <br />route -n (gateway)        |
| DNS        | /etc/resolv.conf                                             | dig www.google.com                                    |
| 主机名     | /etc/sysconfig/network <br />/etc/hosts                      | hostname (主机名) <br />ping $(hostname) <br />reboot |

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE="eth0"               <==网卡名称，必须要 ifcfg-eth0 相对应
HWADDR="08:00:27:71:85:BD"  <==就是MAC地址，若只有一张网卡，可省略此项目
NM_CONTROLLED="no"          <==不要受到其他软件的网络管理！
ONBOOT="yes"                <==是否默认启动此接口的意思
BOOTPROTO=none              <==取得IP的方式，其实关键词只有dhcp，手动可输入none 重要
IPADDR=192.168.1.100        <==就是 IP 啊
NETMASK=255.255.255.0       <==就是子网掩码
GATEWAY=192.168.1.254       <==就是默认路由
# 重点是上面这几个设定项目，底下的则可以省略的啰！
NETWORK=192.168.1.0         <==就是该网段的第一个 IP，可省略
BROADCAST=192.168.1.255     <==就是广播地址啰，可省略
MTU=1500                    <==就是最大传输单元的设定值，若不更改则可省略
```



配置完成后，我们重新启动网络接口，才能更新整个网络参数

```bash
/etc/init.d/network restart

#检查配置
#1.查看IP参数是否正确,重点是IP与Netmask
ifconfig eth0

#2.检查一下路由定义是否正确
route -n
192.168.1.254

#3.测试看看与路由器之间是否能够连接成功
ping -c 3 192.168.1.254
```

这三步配置完之后，TCP/IP参数就配置完毕，可以使用 IP 上网了，不能够使用主机名上网，因为没有定义 DNS



> DNS服务器IP的定义与查看

/etc/resolv.conf 会影响到是否可以查询到主机名称与IP的映射

```bash
#DNS服务器地址
vim /etc/resolv.conf
nameserver 168.95.1.1
nameserver 139.175.10.20 

#4.检测定义的DNS服务器是否提供域名解析
dig www.baidu.com
```



> 主机名的修改、启动与查看

修改主机名需要修改 `/etc/sysconfig/network` 和 `/etc/hosts` 这两个文件

```bash
vim /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=www.centos.vbird

[root@www ~]# vim /etc/hosts
192.168.1.100    www.centos.vbird
# 特别注意，这个档案的原本内容不要删除！只要新增额外的数据即可！

> hostname  #查看是否修改成功了

#5.检测主机名有没有对应的IP
ping -c 2 www.centos.vbird
```

**当修改过 /etc/sysconfig/network 里面的 HOSTNAME 后，必须重新启动 (reboot)**



### 4.2.2 自动取得IP参数

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
HWADDR="08:00:27:71:85:BD"
NM_CONTROLLED="no"
ONBOOT=yes
BOOTPROTO=dhcp
```

```bash
#重启
/etc/init.d/network restart
```

基本上，/etc/resolv.conf 默认会被 DHCP 所修改过，因此你不需要修改 /etc/resolv.conf。甚至连主机名都会被 DHCP 所修订。不过，如果你有特殊需求，那么 /etc/sysconfig/network 以及 /etc/hosts 请自行修改正确呦



检测配置的5个步骤

```bash
ifconfig
route -n
ping GW 的 IP  #ping路由的ip
dig www.baidu.com
hostname
```



当我们需要主机名与IP的对应时，系统后先到 `etc/hosts` 文件查询对应的设置值，如果找不到，才会使用 `/etc/resolv.conf` 的设置去因特网查询



---

IP 参数设置在 `/etc/sysconfig/network-scripts/ifcfg-eth0` 中

主机名 设置在 `/etc/sysconfig/network` 中

DNS 设置在 `/etc/resolv.conf` 中

主机名与IP的对应 设置在 `/etc/hosts` 中



# 第5章 Linux常用的网络命令

![常用的网络命令](http://s.i9u.cc/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4.png)

## 5.1 设置网络参数的命令

ifconfig  查询、设置网卡与IP网络等相关参数

ifup ifdown  这是两个script文件,其作用是通过更简单的方式启动和关闭网络接口

route  查看、配置路由表(route table)

ip  整合式的命令，可以直接修改上述提到的功能



### ifconfig

> ifup 与 ifdown 仅能根据 /etc/sysconfig/network-scripts 内的 ifcfg-ethX(X为数字)进行启动或关闭的操作，并不能直接修改网络参数，除非手动调整 ifcfg-ethX 文件才行。=> 可以针对指定的网卡进行关闭和开启
>
> ifconfig 则可以直接手动为某个接口配置 IP 或调整其网络参数

```bash
#可以手动启动、查看与修改网络接口的相关参数
ifconfig

#查看所有的网络接口
#直接输入 ifconfig 会列出当前已经被启动的网卡,不管这个网卡是否有被设置IP,都会被显示出来
ifconfig

#显示eth0这块网卡的相关数据，不管该网卡是否启动
ifconfig eth0

ifconfig eth0 192.168.100.100

> ifconfig eth0 192.168.100.100 \
netmask 255.255.255.128 mtu 8000

#eth0:0 在该实体网卡上,再仿真一个网络接口 在一张网卡上面设置多个IP的意思
> ifconfig eth0:0 192.168.50.50 

> ifconfig eth0:0 down

#将手动的处理全部取消 使用原有的设置值重置网络参数
/etc/init.d/network restart
```



使用 ifconfig 可以暂时手动来设置或修改某个适配卡的相关配置，然后可以使用 /etc/init.d/network restart 来重新启动整个网络接口，那么之前手动设置的数据就会全部失效。

要启动某个网络接口，又不让它具有IP参数时，直接使用 ifconfig eth0 up 即可



---



### ifup/ifdown

实时手动修改网络接口参数，可以利用 ifconfig 来实现。如果要直接以配置文件，就是 `/etc/sysconfig/network-scripts` 里边的 ifcfg-ethx 等文件的设置参数来启动网络接口的话，需要 ifup 或 ifdown 来完成



```bash
ifup eth0
ifdown eth0
```



ifup 与 ifdown 其实是 script ，它会直接到 /etc/sysconfig/network-scripts 目录下查找对应的配置文件。例如 ifup eth0 ,它会读取 ifcfg-eth0 整个文件的内容，加以设置。



### 修改路由 route

```bash
#单纯查看路由
route -n

route
```



route 与 route -n 的区别是 -n 参数会显示出 IP，至于只使用 route 命令，显示的则是 “主机名”。默认情况下，route 会解析出该 IP 的主机名。

路由是有顺序的，数据从小网络到大网络。

```bash
#腾讯服务器的路由
[root@VM_0_7_centos ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.21.0.1      0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0
```

解读一下：如果要传送到 baidu 的主机。百度的主机IP是 180.149.131.98 

1. 判断百度的主机IP在不在 172.21.0.0/20 范围里
2. 判断百度的主机IP在不在 169.254.0.0/16 范围里
3. 到达默认路由，通过eth0将数据包发送给 172.21.0.1 这台 Gateway 主机。所以说路由是有顺序的。



### 网络参数综合命令 ip

综合了 ifconfig 与 route 这两个命令。

```bash
ip [option] [动作] [命令]
选项与参数
-s            显示出设备的统计数据
link          与设备device相关的设置 包括MTU、MAC地址等
addr/address  关于额外的IP协议,例如多IP的实现等
route         与路由有关的相关设置
```



```bash
#ip link 第二层数据链路层
#显示本机所有接口的信息
ip link show
ip link set eth0 up
ip link set eth0 down

#ip address 第三层网络层
ip address show
ip addr
ip addr show eth0

#ip route功能几乎与route差不多
#显示当前的路由信息
ip route show
```



## 5.2 网络排错与查看命令

### 两台主机的两点沟通：ping

ping 是个很重要的命令，ping 主要通过 ICMP 数据包来进行整个网络的状态报告

```bash
ping [参数] IP
-c              执行 ping 的次数 -c 5
-n              输出数据时不进行 IP 与 主机名的反查,直接使用IP输出(更快)
-W              等待响应对方主机的秒数

选项与参数：
-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；
-n     ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；
-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；
-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；
-W 数值：等待响应对方主机的秒数。
-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：
   do  ：代表传送一个 DF (Don't Fragment) 旗标，让封包不能重新拆包与打包；
   dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包
   
ping -c 3 168.95.1.1   
```

ping 最简单的功能就是发送 ICMP 数据包去要求对方主机回应是否在网络环境中

### 两主机间各节点分析：traceroute

> ping 是两台主机之间的连通性判断
>
> traceroute 是两台主机之间各个节点(node)的通信状况



```bash
traceroute [选项与参数] IP
选项与参数：
-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！
-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；
-I ：使用 ICMP 的方式来进行侦测；
-T ：使用 TCP 来进行侦测，一般使用 port 80 测试
-w ：若对方主机在几秒钟内没有回声就声明不通...预设是 5 秒
-p 端口号：若不想使用 UDP 与 TCP 的预设端口号来侦测，可在此改变端口号。
-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；
         举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个 ppp，
         你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！
-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。

traceroute -n tw.yahoo.com  #UDP检测
traceroute -w 1 -n -T www.baidu.com
```



### 查看本机的网络连接与后门 netstat

某个网络服务明明已经启动了，但是就是无法进行连接，要先查询下网络接口所监听的端口(port)，看看是否真的启动。



```bash
netstat -[rn]       <==与路由有关的参数
netstat -[antulpc]  <==与网络接口有关的参数
选项与参数：
与路由 (route) 有关的参数说明：
-r  ：列出路由表(route table)，功能如同 route 这个指令；
-n  ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n
与网络接口有关的参数：
-a  ：列出所有的联机状态，包括 tcp/udp/unix socket 等；
-t  ：仅列出 TCP 封包的联机；
-u  ：仅列出 UDP 封包的联机；
-l  ：仅列出有在 Listen (监听) 的服务之网络状态；
-p  ：列出 PID 与 Program 的檔名；
-c  ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
```

```bash
#列出目前的路由表状态，且以 IP 及 port number 显示  
#route -n 一模一样
netstat -rn

#列出目前的所有网络联机状态，使用 IP 与 port number
netstat -an

#显示目前已经启动的网络服务
netstat -tunlp
```



服务名称与port number的对应关系在哪个文件？

/etc/services



### 检测主机名与IP的对应 host nslookup

#### host

这个指令可以查出某个主机名的IP

```bash
host [-a] hostname [server]
选项与参数：
-a ：列出该主机详细的各项主机名设定数据
[server] ：可以使用非为 /etc/resolv.conf 的 DNS 服务器 IP 来查询

host www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 220.181.112.244

host命令是向 /etc/resolv.conf 这个文件内的DNS服务器IP来查询的
```



#### nslookup

用途与host基本一样.也是通过 /etc/resolv.con 来进行DNS的查询

```bash
nslookup [-query=[type]] [hostname|IP]
选项与参数：
-query=type：查询的类型，除了传统的 IP 与主机名对应外，DNS 还有很多信息，
             所以我们可以查询很多不同的信息，包括 mx, cname 等等，
             例如： -query=mx 的查询方法！

#找出 www.google.com 的IP
nslookup www.baidu.com
Server:		192.168.1.1
Address:	192.168.1.1#53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com.
Name:	www.a.shifen.com
Address: 220.181.112.244

> cat /etc/resolv.conf 
nameserver 183.60.83.19                                                                 
nameserver 183.60.82.98

> nslookup www.baidu.com
Server:         183.60.83.19       #注意这里                                                      
Address:        183.60.83.19#53                                                         
                                                                                        
Non-authoritative answer:                                                               
www.baidu.com   canonical name = www.a.shifen.com.                                      
Name:   www.a.shifen.com                                                                
Address: 180.149.131.98 
```

## 5.3 远程连接命令与即时通信软件

### telnet

> 可以用来检测某个网站的端口是否开放
>
> telnet www.baidu.com 80

```bash
telnet [host|IP [port]]

#连接bbs站点
yum install telnet
telnet ptt.cc

#telnet 还可以用来连接到某个port(服务)上
#telnet 连接到 port 110,来查看整个port是否正确启动
telnet localhost 110

telnet localhost 25
```



## 5.4 文字接口网页浏览

### links

```bash
links [options] [URL]
选项与参数：
-anonymous [0|1]：是否使用匿名登录的意思；
-dump [0|1]     ：是否将网页的数据直接输出到 standard out 而非 links 软件功能
-dump_charset   ：后面接想要透过 dump 输出到屏幕的语系编码，big5 使用 cp950 喔

links http://www.baidu.com
```



因为你的环境可能是在 Linux 本机的 **tty1~tty6** ，所以无法显示出中文，这个时候你就得要设定为： 『LANG=en_US』之类的语系设定才行



### wget 文字接口下载器

> links 是进行网页的浏览
>
> wget 是进行网页数据的下载。wget是使用浏览器进行下载

```bash
wget [option] [网址]
选项与参数：
若想要联机的网站有提供账号与密码的保护时，可以利用这两个参数来输入喔！
--http-user=usrname
--http-password=password
--quiet ：不要显示 wget 在抓取数据时候的显示讯息
更多的参数请自行参考 man wget 吧！ ^_^

#代理proxy需要修改 /etc/wgetrc 来设置

wget http://www.baidu.com
```



### nc

nc 命令可以用来作为某些服务的检测，因为它可以连接到某个port来进行通信，此外，还可以自行启动一个port来监听其他用户的连接。

```bash
nc [-u] [IP|host] [port]
[root@www ~]# nc -l [IP|host] [port]
选项与参数：
-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；
-u ：不使用 TCP 而是使用 UDP 作为联机的封包状态

nc localhost 25
```



# 第6章 Linux网络排错

## 6.1 无法连接网络的原因分析

### 软件问题

IP参数设置、路由设置、服务器与防火墙设置



### 问题处理

1) 确认IP 

2) 确认局域网连接

​    利用 ping 来沟通两台主机（或路由器）

3) 确认对外连接

​    ping 外网

4) 确认DNS查询

​    用 nslookup、host或dig检查 www.baidu.com

5) 确认 Internet 节点

​    利用 traceroute 检查各节点是否有问题



## 疑问

:question: 1M 上行和下行是多少？

1M 不是1MB而是1Mb。大B是字节，小b是比特位。1B=8b,所以1M的实际带宽为1024/8=128K

1M = 1024KB  1024/8=128  (1byte=8bit 1Bps=8bps)

126？



:question: tty1 和 tty6  

linux的几种登录模式。tty2(alt+ctrl+f2) 6个终端

```bash
> w
23:04:42 up 73 days,  6:51,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    27.187.169.166   22:22    2.00s  0.02s  0.00s w

> ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0  1240  1238  0  80   0 - 29139 do_wai pts/0    00:00:00 bash
0 R     0  1405  1240  0  80   0 - 37204 -      pts/0    00:00:00 ps

#TTY 为登录着的终端机位置，若为远程登录则使用动态终端接口(pts/n)
#TTY 该进程在哪个终端机上运行,若与终端机无关则显示?
#tty1-tty6是本机上面的登录者程序,若为pts/0,表示网络连接进主机的进程
```

tty 终端设备的统称 (Teletypes或teletypewriters)，电传打字机，现在叫终端。终端是一种字符型设备，他有多种类型，通常使用tty来简称各种类型的终端设备。

pts/ptmx  pts(pseudo-terminal slave)是pty的实现方法,虚拟终端。

```bash
> ls /dev/pt*
0  1  2  ptmx

> w
 23:19:16 up 73 days,  7:06,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    27.187.169.166   22:22   44.00s  0.05s  0.05s -bash
root     pts/1    27.187.169.166   23:19   12.00s  0.02s  0.02s -bash
root     pts/2    27.187.169.166   23:19    4.00s  0.02s  0.00s w
```

```bash
#虚拟终端 远程连接到linux时的 /dev/pts/0
> tty
/dev/pts/0
```



:question: 浏览器输入 www.baidu.com 发生了什么

DNS解析www.baidu.com解析成ip地址，然后到应用层 > 传输层(TCP) > IP网络层(路由局域网) > 网络接口层



:question: 研究下 wireshark

[网络抓包]: https://www.cnblogs.com/doit8791/p/5730595.html

[wireshark抓包工具详细说明及操作使用]: https://blog.csdn.net/qq78069460/article/details/79153895
[wireshark基本介绍和学习TCP三次握手]: http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html
[学习Wireshark之二：数据包分析]: http://blog.51cto.com/skypegnu1/1540728
[wireshark基本用法]: http://www.cnblogs.com/dragonir/p/6219541.html
[TCP三次握手]: http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html	"看看这个 自己录制了git视频"





# 第7章 网络安全与主机基本防护

> 限制端口、网络升级与SELinux

## 7.1 网络数据包连接进入主机的流程

![image-20190512063155921](http://s.i9u.cc/image-20190512063155921.png)



### 1.经过防火墙的分析

默认Linux防火墙有两个独立存在机制，因此默认有两层防火墙：第一层是**数据包过滤式的 Net Filter 防火墙**；第二层是通过**软件管理的 TCP Wrappers 防火墙**

1. 数据包过滤式防火墙：IP Filtering 或 Net Filter

   就是 iptables 这个软件所提供的防火墙功能。主要针对 TCP/IP 的数据包头部进行过滤的机制，分析的是 OSI 的第二、三、四层，主要控制的是 MAC、IP、ICMP、TCP与UDP的端口与状态（SYN、ACK）等。

2. TCP Wrappers

   `/etc/hosts.allow` 与 `/etc/hosts.deny` 的配置文件。针对 TCP 的 Header 进行再次分析，设置机制来过滤某些 IP 或 Port，让来源端的数据包被丢弃或通过检验

### 2. 服务的基本功能

举例httpd服务：在 http.conf 配置文件里配置某些IP来源不能使用 httpd 这个服务来获取主机的数据，那么即使该IP通过了前边两层，也无法获取到主机的资源

### 3. SELinux 对网络服务的详细权限控制

### 4. 使用主机的文件系统资源

文件权限的 rwx 权限



除了上述的步骤外，还具有支持**登陆文件日志记录**的功能。尤其是 `/var/log/messages` 与 `/var/log/secure` 这些文件



---

### DDoS攻击

分布式拒绝服务攻击，通过分散在各地的僵尸计算机进行攻击，让你的系统所提供的服务被阻断而无法顺利的为其他用户提供服务的方式。最常用的是 SYN Flood 攻击法。

原理是：当主机接收了一个带有 SYN 的 TCP 数据包之后，就会启动对方要求的 Port 来等待连接，并且发送出回应数据包（带有 SYN/ACK 标志的 TCP 数据包），等待 Client 端的再次回应。

如果 Client 端发送出 SYN 的数据包后，但是将来自 Server 端的确认数据包丢弃，那么 Server 端就会一直空等。Client 端通过软件短时间持续发送这样的 SYN 数据包，Server 就会持续不断的发送确认数据包，并开启大量的 Port 在空等，等全部主机的 Port 都启用完毕，那系统就挂了。

**DDos 攻击手法不是入侵你的系统，而是让你的系统无法正常提供服务。**



主机防护的几个方向

1. 完善的登陆密码规则限制
2. 完善的主机权限设置
3. 设置自动升级与修补软件漏洞以及移除危险软件
4. SELinux
5. iptables、TCP Wrappers 强化网络防火墙
6. 利用主机监控软件（logwatch） 分析主机状况与日志文件



系统保护的几个手段

1. 随时更新系统软件
2. 限制连接端口
3. 启动 SELinux 限制网络服务的权限

## 7.2 网络自动升级软件

rpm 具有所谓的依赖性，有一些软件的基本信息，并同时记录了软件的依赖性`rpm -q`。所以分析这些基本信息并使用一些机制将这些依赖信息记录下来后，再通过一些额外的网络功能，就能够自动分析系统与修补软件之间的差异，进一步实现自动升级 => yum

### yum 软件更新、镜像站点使用原理

> CentOS 可在 yum 服务器上 下载官网给出的 rpm 表头列表数据，该数据记载了每个 rpm 软件的依赖性，也指明了 rpm 文件所放置的容器（Repository）。通过分析这些数据，CentOS 能够直接使用 yum 去下载与安装所需要的软件了

![image-20190512075806446](http://s.i9u.cc/image-20190512075806446.png)



详细流程如下：

1) 先由配置文件判断 yum Server 所在的 IP 地址

2) 连接到 yum Server 后，先下载新的 rpm 文件的表头数据

3) 分析比较用户要安装/升级的文件，并提示用户确认

4) 下载用户选择的文件到系统中的 `/var/cache/yum`，并进行实际安装



由于所下载的清单当中已经含有所有官方网站给出的 rpm 文件的表头依赖属性的关系，所以如果你想要安装的软件包括某些尚未安装的依赖性软件时，yum 会顺便帮你下载所需要的其他软件。预安装后，再安装你所实际需要的软件。

全世界如果都使用同一台 yum 服务器去下载所需要的 rpm 文件，带宽会被塞爆，可以通过镜像站点来解决。CentOS 世界各地都有镜像站点，将官网的 yum 服务器的数据复制一份，同时在镜像站点上提供同样的 yum 功能，你可以在任何一台 yum 服务器的镜像站点上面下载与安装软件。

yum 很聪明，自动分析离你的主机最近的那个镜像站点。



### yum 的功能：安装软件组、全系统更新

> yum 不仅提供在线自动升级，还用于查询、软件组的安装、整体版本的升级

```bash
# list search info install remove clean update
yum [option] [查詢的工作項目] [相關參數]
選項與參數：
option：主要的參數，包括有：
   -y ：當 yum 詢問使用者的意見時，主動回答 yes 而不需要由鍵盤輸入；

[查詢的工作項目]：由於不同的使用條件，而有一些選擇的項目，包括：
   install ：指定安裝的軟體名稱，所以後面需接『 軟體名稱 』
   update  ：進行整體升級的行為；當然也可以接某個軟體，僅升級一個軟體；
   remove  ：移除某個軟體，後面需接軟體名稱；
   search  ：搜尋某個軟體或者是重要關鍵字；
   list    ：列出目前 yum 所管理的所有的軟體名稱與版本，有點類似 rpm -qa；
   info    ：同上，不過有點類似 rpm -qai 的執行結果；
   clean   ：下載的檔案被放到 /var/cache/yum ，可使用 clean 將他移除，
             可清除的項目：packages | headers | metadata | cache 等；

# list info install remove
在[查詢的工作項目]部分還可以具有整個群組軟體的安裝方式，如下所示：
   grouplist   ：列出所有可使用的『軟體群組』，例如 Development Tools 之類的；
   groupinfo   ：後面接 group_name，則可瞭解該 group 內含的所有軟體名；
   groupinstall：這個好用！可以安裝一整組的軟體群組，相當的不錯用！
                 更常與 --installroot=/some/path 共用來安裝新系統
   groupremove ：移除某個軟體群組；
```

```bash
# 搜索 CentOS 官网提供的软件名称是否与 raid 相关的
> yum search raid

# 查询 madam 的具体功能
> yum info madam
```

yum 可以查询包含某些特殊字符的软件名称。有两种方式取得软件名称

* yum search '一些关键字'
* yum list (可列出所有的软件文件名)

然后再用正则表达式取得关键字，或者是 `yum info '软件名称'` 就能够知道该软件的用途。



#### 通过 yum 进行安装

```bash
> yum list javacc*

> yum install javacc
```

通过 yum，我们可以很轻松的安装好一个软件，并且这个软件已经主动帮我们做好依赖性属性。

CentOS 6 默认情况下，yum 下载的数据除了每个容器的表头清单文件之外，所有下载的 rpm 文件都会在安装完毕之后予以删除。如果需要保留在 `/var/cache/yum` 中，需要修改 `/etc/yum.conf` 配置文件

```bash
> vim /etc/yum.conf
[main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=1     #这一行
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
```



#### 安装软件组

```bash
# 查询系统的软件组有多少个
> yum grouplist

# Desktop Platform 内包含多少个 rpm 软件
> yum groupinfo 'Desktop Platform'

# 安装 Desktop Platform
> yum groupinstall 'Desktop Platform'
```

利用`yum groupinstall '软件组名'`可以一口气安装很多软件，不必担心某个软件忘记安装了



#### 全系统更新

使用 `yum update` 可以进行软件的安装。`yum update` 也可以直接进行同一版本的升级。

可以使用 `crontab -e` 来操作，也可以编辑 `vim /etc/crontab` 来操作，由于这个更新是**系统方面**的，可以使用 `vim /etc/crontab` 来进行命令的说明

```bash
# 每天的凌晨5:40自动更新
40 5 * * * root yum -y update && yum clean packages
```



### 修改 yum 配置文件与清除 yum 缓存

[http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/](http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/)

最重要的是 repodata 的目录。该目录就是分析 rpm 软件后所产生的**软件属性依赖数据**放置处。

```bash
# 查看原始的配置文件内容
> cat /etc/yum.repos.d/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
```

* mirrorlist

  列出这个容器可以使用的镜像站点。由于下面我们直接设置镜像站点，这行需要注释

* baseurl

  后面的值是容器的实际网址。mirrorlist 是由 yum 程序自行去获取镜像站点，basrurl 是指定固定的一个容器网址

```bash
# 修改后的配置文件
> vim /etc/yum.repos.d/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base
baseurl=http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/   <==就屬它最重要！
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
# 底下其他的容器項目，請自行到高速網路中心去查詢後自己處理！

# 修改过配置文件，最好清除已有清单
> yum clean all 
```

```bash
# 列出目前 yum server 所使用的容器有哪些
# 在 /etc/yum.repos.d/ 下有多个配置文件,所以发现还有其他的容器存在
> yum repolist all
```

我们修改的是系统默认的配置文件 `/etc/yum.repos.d/CentOS-Base.repo` ，实际上，我们应该在 `/etc/yum.repos.d/` 下面新建一个文件，该扩展名必须是 `.repo` 才行。但我们修改了网址没有修改容器名称，可能有缓存存在，所以可以清除一下本机的旧数据。

```bash
> yum clean [packages|headers|all] 
選項與參數：
 packages：将已下载的 软件文件 刪除
 headers ：将下载的的 软件文件头 删除
 all     ：将 所有容器数据 都删除
 
 # 删除已下载过的所有容器的相关数据(含软件本身与列表)
 > yum clean all
```

## 7.3 限制连接端口 Port

当我们启用一个 daemon 时，就会触发主机的端口进行监听的动作。

当启动一个网络服务时，这个服务会依据 TCP/IP 的相关通信协议启动一个端口进行监听，这就是 TCP/UDP 数据包的 Port 端口了。第2章中我们知道网络连接是双向的，服务器端需要启动一个监听的端口，客户端需要随机启动一个端口来接收响应的数据才行。

port 的启动与服务有关。服务与 port 对应的文件是 /etc/services

### 端口的查看 netstat nmap

* netstat 在本机上以自己的程序检测自己的端口
* nmap 通过网络的检测软件辅助，可检测非本机上的其他网络主机



```bash
# 列出正在监听的网络服务
> netstat -tunl

# 列出已连接的网络连接状态
> netstat -tun

# 删除已建立或在监听当中的连接
> netstat -tunp  #pid = 1342

# 不能用 killall,否则容易删除
> kill -9 1342
```



```bash
# nmap
> yum install nmap
> nmap localhost
```



# 第8章 路由的概念与路由器设置

每一台主机都有自己的路由表

```bash
> route -n
Kernel IP routing table
Destination  Gateway        Genmask         Flags Metric Ref  Use Iface
192.168.1.0  0.0.0.0        255.255.255.0   U     0      0      0 eth0 <== 1
169.254.0.0  0.0.0.0        255.255.0.0     U     1002   0      0 eth0 <== 2
0.0.0.0      192.168.1.254  0.0.0.0         UG    0      0      0 eth0 <== 3
```

Linux 系统下的路由表是由小网络排列到大网络，路由是由『 192.168.1.0/24 --> 169.254.0.0/16 --> 0.0.0.0/0 (默认路由) 』來排列的



# 第9章 防火墙与 NAT 服务器

Linux 的防火墙主要是通过 Netfilter 与 TCP Wrappers 两个机制来管理。

Netfilter 防火墙机制，可以实现私有 IP 的主机上网（IP路由器功能），并且也能够让 Internet 连接内部的私有 IP 所架设的 Linux 服务器（DNAT功能）。



## 9.1 认识防火墙

防火墙就是通过定义一些有顺序的规则，并管理进入到网络内的主机数据数据包的一种机制。广义的说，只要能够分析与过滤进出我们管理的网络的数据包的数据，就称为防火墙。

Netfilter 是数据包过滤式的防火墙机制，可以通过 iptables 命令的方式进行规则的排序与修改

### 为何需要防火墙

数据包进入主机时，会通过防火墙、服务器软件程序、SELinux与文件系统权限。

防火墙最大的功能就是帮助你限制某些服务的访问来源。重要任务如下：

* 切割被信任（子域）与不被信任（Internet）的网段
* 划分出可提供 Internet 的服务与必须受保护的服务
* 分析出可接受与不可接受的数据包状态

### 防火墙的类别

依据防火墙管理范围来划分

* 网络型
* 单一主机型
  * 数据包过滤型的 Netfilter
  * 依据服务软件程序作为分析的 TCP Wrappers



Netfilter（数据包过滤机制）

数据包过滤就是分析进入主机的网络数据包，将数据包的**头部数据**提取出来进行分析，以决定该连接为放行或阻挡的机制。包括硬件地址MAC、软件地址IP、TCP、UDP、ICMP 等数据包的信息都可以过滤分析。主要分析的是 OSI七层协议的 2、3、4层。

Linux 内核内建了 Netfilter 这个机制，而 Netfilter 提供了 iptables 这个软件作为防火墙数据包过滤的命令。



TCP Wrappers（程序管理）

这种机制主要分析谁对某程序进行访问，然后通过规则去分析该服务器程序谁能够连接，谁不能连接。

由于主要是通过分析服务器程序来管理，因此**与启动的端口无关，只与程序的名称有关**。

举例：FTP 可以启动在非正规的 port 21 进行监听，当你通过 Linux 内建的 TCP Wrappers 限制 FTP 时，那么你只要知道 FTP 的软件名称（vsftpd），然后对它进行限制，且不管 FTP 启动在哪个端口，都会被该规则管理的。



## 9.2 TCP Wrappers

TCP Wrappers 通过客户端想要链接的程序文件名，然后分析客户端的IP，看看是否需要放行。

TCP Wrappers 是通过 `/etc/hosts.allow`、`/etc/hosts.deny` 来管理类似防火墙的机制。只有下面的软件才能够通过这两个文件来管理防火墙规则：

* 由 super daemon（xinetd）所管理的服务
* 支持 libwrap.so 模块的服务



```bash
<service(program_name)> : <IP, domain, hostname> 
<服务   (也就是程序名称)> : <IP 或域 或主机名>
# 上头的 > < 是不存在与配置文件中的
```



防火墙的规则是有顺序的：

* 先以 /etc/hosts.allow 进行优先比对，该规则符合就予以放行
* 再以 /etc/hosts.deny 比对，规则符合就予以抵挡
* 若不在这两个文件内，亦即规则都不符合，最终则予以放行

```bash
# 开放本机的127.0.0.1进行任何本机的服务
# 局域网(192.168.1.0/24)可以使用rsync,同时10.0.0.100也可以使用rsync
# 其他来源不允许使用rsync
> vim /etc/hosts.allow
ALL: 127.0.0.1    <== 这就是本机全部的服务都接受
rsync: 192.168.1.0/255.255.255.0 10.0.0.100

> vim /etc/hosts.deny
rsync: ALL
```

TCP Wrappers 不支持 192.168.0.1/24 这种网络，只支持 Netmask 的地址显示方式。



## 9.3 数据包过滤软件 iptables

### 数据包进入流程：规则顺序的重要性

iptables 利用的是 数据包过滤的机制，会分析数据包的报头数据。根据报头数据与定义的规则来决定该数据包是否进入主机或者被丢弃。根据数据包的分析资料 "比对" 预先定义的规则内容，若数据包数据与规则内容相同则进行动作，否则就继续下一条规则的比对。

当一个网络数据包要进入主机之前，会先经过 Netfilter 进行检查，就是 iptables 的规则。检查通过则接受（ACCPET） 进入本机取得资源，如果检查不通过，则可能予以丢弃（DROP）。规则是有顺序的。如果规则都不符合，则会走默认操作（数据包策略Policy）。



### iptables 的表格（table）与链（chain）

防火墙软件里有多个表格（table），每个表格都定义出自己的默认策略与规则，且每个表格的用途都不相同。

默认情况下，Linux 的 iptables 至少有3个表格，包括管理本机进出的 Filter、管理后端主机的 NAT、管理特殊标志使用的 Mangle



![image-20190513225745820](http://s.i9u.cc/image-20190513225745820.png)



Filter（过滤器）：主要跟进入 Linux 主机的数据包有关，是默认的 table

​	INPUT : 主要与想要进入 Linux 主机的数据包有关

​	OUTPUT : 主要与 Linux 本机所要送出的数据包有关

​	FORWARD : 与 Linux 本机没有关系，可以传递数据包到后端的计算机中，与 NAT 的 table 有关



NAT（地址转换）：这个表格主要用来进行来源与目的地的 IP 或 port 的转换，与 Linux 主机无关，主要与 Linux 主机后的局域网内计算机有关。



Mangle（破坏者）：这个表格主要与特殊的数据包的路由标志有关



![image-20190513231412073](http://s.i9u.cc/image-20190513231412073.png)



网络是双向的，进入的数据包需要路由判断，送出的数据包也要进行路由判断。

与本机最有关的是 Filter 表格内的 INPUT 与 OUTPUT 链。



### 本机的 iptables 语法

iptables 至少有3个默认的 table（Filter、NAT、Mangle），常用的是本机的 Filter 表格，这也是默认表格。

防火墙的设置主要使用 iptables 命令，因此只能让 root 使用 iptables，不论是设置还是查看防火墙规则。



#### 规则的查看与清除

```bash
iptables [-t tables] [-L] [-nv]    tvnL
选项与参数：
-t ：後面接 table ，例如 nat 或 filter ，若省略此項目，則使用預設的 filter
-L ：列出目前的 table 的規則
-n ：不進行 IP 與 HOSTNAME 的反查，顯示訊息的速度會快很多！
-v ：列出更多的資訊，包括通過該規則的封包總位元數、相關的網路介面等
```

```bash
# 列出 filter table 3条链的规则
> iptables -L -n
Chain INPUT (policy ACCEPT)   <==針對 INPUT 鏈，且預設政策為可接受
target  prot opt source     destination <==說明欄
ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0   state RELATED,ESTABLISHED <==第 1 條規則
ACCEPT  icmp --  0.0.0.0/0  0.0.0.0/0                             <==第 2 條規則
ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0                             <==第 3 條規則
ACCEPT  tcp  --  0.0.0.0/0  0.0.0.0/0   state NEW tcp dpt:22      <==以下類推
REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited

Chain FORWARD (policy ACCEPT)  <==針對 FORWARD 鏈，且預設政策為可接受
target  prot opt source     destination
REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT)  <==針對 OUTPUT 鏈，且預設政策為可接受
target  prot opt source     destination
```

```bash
# 列出 nat table 3条链的规则
> iptable -t nat -L -n
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```



iptables-save 会列出完整的防火墙规则，只是并没有格式化输出。

```bash
iptables-save [-t table]
選項與參數：
-t ：可以僅針對某些表格來輸出，例如僅針對 nat 或 filter 等等
```

```bash
> iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011
*filter                      <==星號開頭的指的是表格，這裡為 filter
:INPUT ACCEPT [0:0]          <==冒號開頭的指的是鏈，三條內建的鏈
:FORWARD ACCEPT [0:0]        <==三條內建鏈的政策都是 ACCEPT 囉！
:OUTPUT ACCEPT [680:100461]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT <==針對 INPUT 的規則
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT  <==這條很重要！針對本機內部介面開放！
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited <==針對 FORWARD 的規則
COMMIT
# Completed on Fri Jul 22 15:51:52 2011
```



```bash
iptables [-t tables] [-FXZ]    XZF
選項與參數：
-F ：清除所有的已訂定的規則；
-X ：殺掉所有使用者 "自訂" 的 chain (應該說的是 tables ）囉；
-Z ：將所有的 chain 的計數與流量統計都歸零

範例：清除本機防火牆 (filter) 的所有規則
[root@www ~]# iptables -F
[root@www ~]# iptables -X
[root@www ~]# iptables -Z
```



#### 定义默认策略

默认策略是指：当数据包不在我们设置的规则之内时，该数据包的通过与否，是以 Policy 的设置为准。

```bash
iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]
選項與參數：
-P ：定義政策( Policy )。注意，這個 P 為大寫啊！
ACCEPT ：該封包可接受
DROP   ：該封包直接丟棄，不會讓 client 端知道為何被丟棄。
```

```bash
# 默认是 filter 表格
[root@www ~]# iptables -P INPUT   DROP
[root@www ~]# iptables -P OUTPUT  ACCEPT
[root@www ~]# iptables -P FORWARD ACCEPT
[root@www ~]# iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
# Completed on Fri Jul 22 15:56:34 2011
# 由於 INPUT 設定為 DROP 而又尚未有任何規則，所以上面的輸出結果顯示：
# 所有的封包都無法進入你的主機！是不通的防火牆設定！(網路連線是雙向的)

# 设置 NAT table 的 PREROUTING 链为可接受
iptables -t nat -P PREROUTING ACCEPT
```



#### 数据包基础：IP、网络及接口设备

```bash
# AIpsdj
> iptables [-AI 鏈名] [-io 網路介面] [-p 協定] \
> [-s 來源IP/網域] [-d 目標IP/網域] -j [ACCEPT|DROP|REJECT|LOG]
選項與參數：
-AI 鏈名：針對某的鏈進行規則的 "插入" 或 "累加"
    -A ：新增加一條規則，該規則增加在原本規則的最後面。例如原本已經有四條規則，
         使用 -A 就可以加上第五條規則！
    -I ：插入一條規則。如果沒有指定此規則的順序，預設是插入變成第一條規則。
         例如原本有四條規則，使用 -I 則該規則變成第一條，而原本四條變成 2~5 號
    鏈 ：有 INPUT, OUTPUT, FORWARD 等，此鏈名稱又與 -io 有關，請看底下。

-io 網路介面：設定封包進出的介面規範
    -i ：封包所進入的那個網路介面，例如 eth0, lo 等介面。需與 INPUT 鏈配合；
    -o ：封包所傳出的那個網路介面，需與 OUTPUT 鏈配合；

-p 協定：設定此規則適用於哪種封包格式
   主要的封包格式有： tcp, udp, icmp 及 all 。

-s 來源 IP/網域：設定此規則之封包的來源項目，可指定單純的 IP 或包括網域，例如：
   IP  ：192.168.0.100
   網域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。
   若規範為『不許』時，則加上 ! 即可，例如：
   -s ! 192.168.100.0/24 表示不許 192.168.100.0/24 之封包來源；

-d 目標 IP/網域：同 -s ，只不過這裡指的是目標的 IP 或網域。

-j ：後面接動作，主要的動作有接受(ACCEPT)、丟棄(DROP)、拒絕(REJECT)及記錄(LOG)
```

```bash
# 设置 lo 为信任的设备，进出 lo 的数据包都予以接受
> iptables -A INPUT -i lo -j ACCEPT
```

```bash
# 只要是内网的 192.168.100.0/24 数据包都接受
> iptables -A INPUT -i eth1 -s 192.168.100.0/24 -j ACCEPT

# 只要是来自 192.168.100.10 就接受,但来自 192.168.100.230 丢弃
> iptables -A INPUT -i eth1 -s 192.168.100.10 -j ACCEPT
> iptables -A INPUT -i eth1 -s 192.168.100.230 -j DROP

> iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 16:00:43 2011
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [17:1724]
-A INPUT -i lo -j ACCEPT
-A INPUT -s 192.168.100.0/24 -i eth1 -j ACCEPT
-A INPUT -s 192.168.100.10/32 -i eth1 -j ACCEPT
-A INPUT -s 192.168.100.230/32 -i eth1 -j DROP
COMMIT
# Completed on Fri Jul 22 16:00:43 2011
```

```bash
# 记录某个规则的记录
# 只要数据包来自 192.168.2.200这个IP时,该数据包的相关信息就会写入内核日志文件(/var/log/messages).然后继续比对后续的规则.LOG动作只进行日志记录,不影响规则的比对
> iptables -A INPUT -s 192.168.2.200 -j LOG
> iptables -L -n
target prot opt source         destination
LOG    all  --  192.168.2.200  0.0.0.0/0   LOG flags 0 level 4
```

#### TCP、UDP规则比对：针对端口设置

```bash
> iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \
> [-s 来源IP/网络] [--sport 端口范围] \
> [-d 目标IP/网络] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]
选项与参数：
--sport 端口范围：限制来源的端口号码，端口号可以是连续的，例如 1024:65535
--dport 端口范围：限制目标的端口号码。
```

因为仅有 TCP 与 UDP 数据包具有端口，因此要想使用 `--dport` 和 `--sport` 时，需要加上 `-p tcp` 或 `-p udp` 参数才行

```bash
# 想要进入本机 port 21 的数据包阻挡掉
> iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP

# TCP数据包还有特殊的标志 主动连接SYN标志
# 将来自任何地方来源port 1:1023 的主动连接到本机端的 1:1023 连接丢弃
iptables -A INPUT -i eth0 -p tcp --sport 1:1023 --dport 1:1023 --syn -j DROP
```



#### iptables 外挂模块：mac与state

可以通过一个状态模块来分析：**想要进入的数据包是否为刚刚发出去的响应**，如果是刚刚发出去的响应，就可以予以接受放行。

```bash
iptables -A INPUT [-m state] [--state 狀態]
選項與參數：
-m ：一些 iptables 的外掛模組，主要常見的有：
     state ：狀態模組
     mac   ：網路卡硬體位址 (hardware address)
--state ：一些封包的狀態，主要有：
     INVALID    ：無效的封包，例如資料破損的封包狀態
     ESTABLISHED：已經連線成功的連線狀態；
     NEW        ：想要新建立連線的封包狀態；
     RELATED    ：這個最常用！表示這個封包是與我們主機發送出去的封包有關

範例：只要已建立或相關封包就予以通過，只要是不合法封包就丟棄
[root@www ~]# iptables -A INPUT -m state \
> --state RELATED,ESTABLISHED -j ACCEPT
[root@www ~]# iptables -A INPUT -m state --state INVALID -j DROP
```

```bash
範例：針對區域網路內的 aa:bb:cc:dd:ee:ff 主機開放其連線
[root@www ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff \
> -j ACCEPT
選項與參數：
--mac-source ：就是來源主機的 MAC 啦！
```



---

防火墙的设置规则：

1. 规则归零：清除所有已存在的规则（iptables -F）

2. 默认策略：INPUT这个链定义为DROP，其他默认为ACCEPT

3. 信任本机：lo 设置为信任设备

4. 回应数据包：本机主动向外发出请求而响应的数据包可以进入本机

5. 信任用户

   

```bash
# 1. 清除規則
iptables -F
iptables -X
iptables -Z

# 2. 設定政策
iptables -P   INPUT DROP
iptables -P  OUTPUT ACCEPT
iptables -P FORWARD ACCEPT

# 3~5. 制訂各項規則
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT
#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT

# 6. 寫入防火牆規則設定檔
/etc/init.d/iptables save
```



# 第10章 合法的主机名-域名

DNS 的功能就是 **将计算机主机的名称转译成 IP**，让主机名对应IP的解析上。

![image-20190514065146013](http://s.i9u.cc/image-20190514065146013.png)



主机名的目的在辅助人们记忆 TCP/IP 的 IP 数值

主机名与IP的对应，由早期的 /etc/hosts 变更为 DNS 系统来记录



0526 继续读书呀



# 第11章 远程连接服务器 SSH

远程连接服务器通过文字或图形接口的方式来远程登陆系统，让你在远程的终端前面登陆 Linux 主机以取得可操作主机的接口（shell），而登陆后的操作感觉上就像坐在系统前面一样！



**数据的明文传输与加密传输**

明文传输：当我们的数据包在网络上传输时，该数据包的内容为数据的原始格式

加密传输：通过 SSH 协议传输信息时，因为数据是加密过的，所以信息比较安全



## 11.1 文件接口连接服务器 SSH服务器

> SSH 是 Secure Shell Protocol 的简写（安全的壳程序协议），可以通过数据包加密技术将等待传输的数据包加密后再传输到网络上。



SSH 协议提供了两个服务器的功能

* 类似 Telnet 的远程连接使用 Shell 的服务器，称为 SSH
* 类似 FTP 服务的 Sftp-Server，提供更安全的 FTP 服务



## 11.2 连接加密技术

目前常见的网络数据包加密技术通常是 **"非对称密钥系统"** 。主要是通过两把不一样的公钥和私钥（Public and Private Key）来进行加密与解密的过程。由于这两把钥匙的作用是提供数据加解密的，所以在同一个方向的连接中，这两把钥匙是需要成对的

* 公钥（Public Key） 提供给远程主机进行数据加密的行为。所有人都可以获得公钥来将数据加密
* 私钥（Private Key）远程主机使用你的公钥加密的数据，在本地端能够使用私钥进行解密。私钥很重要，不能外流，只能保存在自己的主机上。

由于每台主机都有自己的密钥（公钥与私钥），且公钥用来加密而私钥用来解密，其中私钥不可外流，但因为网络连接是双向的，所以，每个人应该都要有对方的"公钥"才对。

客户端视角：取得服务器端的公钥，然后将自己的公钥发送给服务器端，最终客户端上面的密钥是：服务器的公钥 + 客户端自己的私钥 组成。



SSH 协议版本有两种，Version 1 与 Version 2。Version 2 加上了连接检测的机制，可以避免连接期间被插入恶意的攻击码，因此比 Version 1 更加安全。推荐



![](http://cn.linux.vbird.org/linux_server/0310telnetssh_files/ssh-keypair2.gif)



1. 服务器建立公钥文件：第一次启动 SSHD 服务时，该服务会主动去找 `/etc/ssh/ssh_host*` 文件，如果没有则自动生成。
2. 客户端主动连接要求：客户端想要连接到 SSH 服务器，需要用合适的客户端程序来连接（putty）
3. 服务器传送公钥文件给客户端：接收到客户端的要求后，服务器将第一个步骤取得的公钥文件传送给客户端使用（明码传送，公钥可以给大家使用）
4. 客户端记录/比对服务器的公钥数据及随机计算自己的公私钥
   1. 如果客户端第一次连接到此服务器，会将服务器的公钥数据记录到客户端的用户主目录内的 `~/.ssh/known_hosts`
   2. 如果已经记录过该服务器的公钥数据，则客户端会去比对此次接收到的与之前的记录是否有差异。若开始接收公钥数据，则开始计算客户端自己的公私钥数据
5. 返回客户端的公钥数据到服务器端：用户将自己的公钥数据传送给服务器。此时服务器具有服务器的私钥和客户端的公钥，而客户端具有服务器的公钥和客户端自己的私钥。此次连接的服务器与客户端的密钥系统（公钥+私钥）并不一样，所以称为**非对称式密钥系统** 
6. 开始双向加解密：
   1. 服务器到客户端：服务器传送数据时，拿用户的公钥加密后进行发送，客户端接收后，用自己的私钥解密
   2. 客户端到服务器：客户端传送数据时，拿服务器的公钥加密后进行发送，服务器接收后，用服务器的私钥解密



通过第4步，客户端的密钥是随机运算产生与本次连接当中的，所以这次的连接与下次的连接密钥可能会不一样。此外客户端的用户主目录下的 `~/.ssh/known_hosts` 中会记录曾经连接过的主机的 Public Key，用于确认我们已连接上正确的服务器。



如何产生新的服务器端的 SSH 公钥和私钥呢？

由于服务器提供的公钥和私钥都放置在 `/etc/ssh/ssh_host*` 可以这样做

```bash
> rm /etc/ssh/ssh_host*    #删除密钥文件

> /etc/init.d/sshd restart 
正在停止 sshd:                         [  确定  ]
正在产生 SSH1 RSA 主机密钥:            [  确定  ] <==底下三个步骤重新产生密钥！
正在产生 SSH2 RSA 主机密钥:            [  确定  ]
正在产生 SSH2 DSA 主机密钥:            [  确定  ]
正在激活 sshd:                         [  确定  ]

> ll /etc/ssh/ssh_host*
-rw-------. 1 root root  668 Jul 25 11:35 /etc/ssh/ssh_host_dsa_key
-rw-r--r--. 1 root root  590 Jul 25 11:35 /etc/ssh/ssh_host_dsa_key.pub
-rw-------. 1 root root  963 Jul 25 11:35 /etc/ssh/ssh_host_key
-rw-r--r--. 1 root root  627 Jul 25 11:35 /etc/ssh/ssh_host_key.pub
-rw-------. 1 root root 1675 Jul 25 11:35 /etc/ssh/ssh_host_rsa_key
-rw-r--r--. 1 root root  382 Jul 25 11:35 /etc/ssh/ssh_host_rsa_key.pub
# 看一下上面输出的日期与档案的建立时间，刚刚建立的新公钥、私钥系统！
```

### 启动 SSH 服务

```bash
> /etc/init.d/sshd restart
> netstat -tlnp | grep ssh
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID/Program name
tcp        0      0 :::22          :::*             LISTEN  1539/sshd
```



### SSH 客户端连接程序—Linux用户

SSH 在 Client 端使用的是 SSH 这个指令

```bash
> ssh [-f] [-o 参数项目] [-p 非正规埠口] [账号@]IP [指令]
选项与参数：
-f ：需要配合后面的 [指令] ，不登入远程主机直接发送一个指令过去而已；
-o 参数项目：主要的参数项目有：
	ConnectTimeout=秒数 ：联机等待的秒数，减少等待的时间
	StrictHostKeyChecking=[yes|no|ask]：预设是 ask，若要让 public key 主动加入 known_hosts ，则可以设定为 no 即可。
-p ：如果你的 sshd 服务启动在非正规的埠口 (22)，需使用此项目；
[指令] ：不登入远程主机，直接发送指令过去。但与 -f 意义不太相同。
```

```bash
#直接连接登陆到对方的主机,以本机为例
ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
RSA key fingerprint is eb:12:07:84:b9:3b:3f:e4:ad:ba:f1:85:41:fc:18:3b.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '127.0.0.1' (RSA) to the list of known hosts.
root@127.0.0.1's password: <==在这里输入 root 的密码即可！
Last login: Mon Jul 25 11:36:06 2011 from 192.168.1.101

[root@www ~]# exit  <==离开这次的 ssh 联机
# 由于 ssh 后面没有加上账号，因此预设使用当前的账号来登入远程服务器
```



一般使用 SSH 登陆远程主机，采用 "SSH 账号名称 IP" 的格式。为了习惯，可以使用类似 E-mail 的方式登陆远程主机。`ssh student@127.0.0.1` 

上面的信息中，开头 RSA 的那行后面接的就是 **远程服务器的公钥指纹码**，如果确认没问题，输入 Yes 将该指纹码写入服务器公钥记录文件 `~/.ssh/konwn_hosts`，以便对比该服务器的正确性。

```bash
# 2. 使用 student 账号登入本机
[root@www ~]# ssh student@127.0.0.1
student@127.0.0.1's password:
[student@www ~]$ exit
# 由于加入账号，因此切换身份成为 student 了！另外，因为 127.0.0.1 曾登入过，
# 所以就不会再出现提示你要增加主机公钥的讯息啰！

# 3. 登入对方主机执行过指令后立刻离开的方式：
[root@www ~]# ssh student@127.0.0.1 find / &> ~/find1.log
student@localhost's password:
# 此时你会发现怎么画面卡住了？这是因为上头的指令会造成，你已经登入远程主机，
# 但是执行的指令尚未跑完，因此你会在等待当中。那如何指定系统自己跑？

# 4. 与上题相同，但是让对方主机自己跑该指令，你立刻回到近端主机继续工作：
[root@www ~]# ssh -f student@127.0.0.1 find / &> ~/find1.log
# 此时你会立刻注销 127.0.0.1 ，但 find 指令会自己在远程服务器跑喔！
```

如果想要让远程主机进行关机的指令，如果不加上 -f 的参数，那会等待对方主机关机完毕后才讲本机断开连接。因此，加上 -f 指定远程主机自己关机，而不需要在等待。 `ssh -f root@ip shutdown -h now`

```bash
# 5. 删除掉 known_hosts 后，重新使用 root 联机到本机，且自动加上公钥记录
[root@www ~]# rm ~/.ssh/known_hosts
[root@www ~]# ssh -o StrictHostKeyChecking=no root@localhost
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
root@localhost's password:
# 如上所示，不会问你 yes 或 no 啦！直接会写入 ~/.ssh/known_hosts 当中！
```





### 服务器公钥记录文件: `~/.ssh/known_hosts` 

等你登陆远程服务器时，本机会主动利用接收到的服务器的 Public Key 去比对 `~/.ssh/known_hosts` 有无相关的公钥，然后进行下面的操作：

* 若接收到的公钥尚未记录，则询问用户是否记录。Yes则写入 `~/.ssh/known_hosts` 且执行后续工作；若No，则不写入该文件，并退出登陆工作
* 若接收到的公钥已有记录，则比对记录是否相同，若相同，则继续登陆。若不相同，则出现警告信息，且离开登陆的动作。



### 文件异地直接复制 SCP

```bash
[root@www ~]# scp [-pr] [-l 速率] file  [账号@]主机:目录名 <==上传
[root@www ~]# scp [-pr] [-l 速率] [账号@]主机:file  目录名 <==下载
选项与参数：
-p ：保留原本档案的权限数据；
-r ：复制来源为目录时，可以复制整个目录 (含子目录)
-l ：可以限制传输的速度，单位为 Kbits/s ，例如 [-l 800] 代表传输速限 100Kbytes/s

# 1. 将本机的 /etc/hosts* 全部复制到 127.0.0.1 上面的 student 家目录内
[root@www ~]# scp /etc/hosts* student@127.0.0.1:~
student@127.0.0.1's password: <==输入 student 密码
hosts                        100%  207         0.2KB/s   00:00
hosts.allow                  100%  161         0.2KB/s   00:00
hosts.deny                   100%  347         0.3KB/s   00:00
# 文件名显示                   进度  容量(bytes) 传输速度  剩余时间
# 你可以仔细看，出现的讯息有五个字段，意义如上所示。

# 2. 将 127.0.0.1 这部远程主机的 /etc/bashrc 复制到本机的 /tmp 底下
[root@www ~]# scp student@127.0.0.1:/etc/bashrc /tmp
```

**上传和下载的重点是那个冒号:**  连接在冒号后面的就是远程主机的文件。如果要复制目录的话，加上 -r 选项

* 冒号在前，代表从远程主机下载下来
* 冒号在后，代表本机数据上传

**前 => 下载   后 => 上传     前下后上**



## 11.3 SSHD 服务器详细配置

SSHD 服务器的详细设置都放在 `/etc/ssh/sshd_config` 配置文件中。



```bash
> vim /etc/ssh/sshd_config
# Port 22
# PidFile /var/run/sshd.pid

# HostKey /etc/ssh/ssh_host_rsa_key  SSH version 2 使用的 RSA 私钥

# 4.1 登入设定部分
# PermitRootLogin yes
# 是否允许 root 登入！预设是允许的，但是建议设定成 no！

# PubkeyAuthentication yes
# AuthorizedKeysFile      .ssh/authorized_keys
# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。
# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内

PasswordAuthentication yes
# 密码验证当然是需要的！所以这里写 yes 啰！

# PermitEmptyPasswords no
# 若上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，
# 这个项目在是否允许以空的密码登入！当然不许！

# IgnoreUserKnownHosts no
# 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容？
# 当然不要忽略，所以这里就是 no 啦！
```

建议将 root 的登陆权限取消，并将 SSH 版本设定为 2。如果修改过上面这个文件（`/etc/ssh/sshd_config`）,那么就必须重新启动一次 SSHD 才行，`/etc/init.d/sshd restart`



## 11.4 制作不用密码可立即登陆的 SSH 用户

SSH 可以使用 SCP 进行网络复制，可以将 SCP 的指令放置在 crontab 服务中吗？

默认是不允许的，必须远程登陆，与 SCP 互动的输入密码才行。但是我们可以用 **密钥认证系统** 来处理



SSH 可以使用密钥系统来比对数据，并且提供用户数据的加密功能，可以利用这个 Key 就提供用户自己进入主机，而不需要密码。

可以将 Client 产生的 Key 复制到 Server 中，以后 Client 登陆 Server 时，由于两者在 SSH 要连接的信号传递中已经比对过 Key ，所以可以立即进入数据传输接口中，不需要再输入密码。步骤如下（**类似github**）

1. 客户端建立两把钥匙：私钥比较重要。所以这两把钥匙得在发起连接的客户端配置才对。利用 `ssh-keygen` 这个命令
2. 客户端放置好私钥文件：将 Private Key 放在 Client 上面的用户主目录中，也就是 `$HOME/.ssh/` ，注意权限
3. 将公钥放置到服务器端的正确目录与文件中：将 Public Key 放在任何一个想要登陆的服务器端某用户主目录内的 `.ssh/` 里边的认证文件中



![](http://cn.linux.vbird.org/linux_server/0310telnetssh_files/authorized_keys.gif)

---

1. 客户端建立两把钥匙。如果不指定特殊的算法，默认以 RSA 算法来处理

   ```bash
   > ssh-keygen [-t rsa|dsa] <==可选 rsa 或 dsa
   
   > ssh-keygen  <==用默认的方法建立密钥
   Generating public/private rsa key pair.
   Enter file in which to save the key (/home/vbirdtsai/.ssh/id_rsa): <==按 enter
   Created directory '/home/vbirdtsai/.ssh'. <==此目录若不存在则会主动建立
   Enter passphrase (empty for no passphrase): <==按 Enter 不给密码
   Enter same passphrase again: <==再输入一次 Enter 吧！
   Your identification has been saved in /home/vbirdtsai/.ssh/id_rsa. <==私钥档
   Your public key has been saved in /home/vbirdtsai/.ssh/id_rsa.pub. <==公钥档
   The key fingerprint is:
   0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 vbirdtsai@clientlinux.centos.vbird
   
   > ls -ld ~/.ssh; ls -l ~/.ssh
   drwx------. 2 vbirdtsai vbirdtsai 4096 2011-07-25 12:58 /home/vbirdtsai/.ssh
   -rw-------. 1 vbirdtsai vbirdtsai 1675 2011-07-25 12:58 id_rsa      <==私钥档
   -rw-r--r--. 1 vbirdtsai vbirdtsai  416 2011-07-25 12:58 id_rsa.pub  <==公钥档
   ```

   当我执行 `ssh-keygen` 时候，会在家目录下的 `.ssh/` 目录下产生所需的两个 Keys，分别是 私钥（id_rsa）和公钥（id_rsa.pub）。`~/.ssh` 目录的权限必须是 700 才行

2. 将公钥文件数据上传到服务器上

   ```bash
   #用scp来复制文件 冒号的意义是:前下后上
   scp ~/.ssh/id_rsa.pub dmtsai@192.168.100.254:~
   ```

3. 将公钥放置服务器端正确目录与文件名

   在 `/etc/ssh/sshd_config` 配置文件中的 `AuthorizedKeysFile` 的值就是在指定公钥数据应该要放置的文件名。我们将刚刚上传的 `id_rsa.pub` 数据附加到 `authorized_keys` 这个文件内

   ```bash
   # 1. 建立 ~/.ssh 档案，注意权限需要为 700 喔！
   [dmtsai@www ~]$ ls -ld .ssh
   ls: .ssh: 没有此一档案或目录
   # 由于可能是新建的用户，因此这个目录不存在。不存在才作底下建立目录的行为
   
   [dmtsai@www ~]$ mkdir .ssh; chmod 700 .ssh
   [dmtsai@www ~]$ ls -ld .ssh
   drwx------. 2 dmtsai dmtsai 4096 Jul 25 13:06 .ssh
   # 权限设定中，务必是 700 且属于使用者本人的账号与群组才行！
   
   # 2. 将公钥档案内的数据使用 cat 转存到 authorized_keys 内
   [dmtsai@www ~]$ ls -l *pub
   -rw-r--r--. 1 dmtsai dmtsai 416 Jul 25 13:05 id_rsa.pub <==确实有存在
   
   [dmtsai@www ~]$ cat id_rsa.pub >> .ssh/authorized_keys
   [dmtsai@www ~]$ chmod 644 .ssh/authorized_keys
   [dmtsai@www ~]$ ls -l .ssh
   -rw-r--r--. 1 dmtsai dmtsai 416 Jul 25 13:07 authorized_keys
   # 这个档案的权限设定中，就得要是 644 才可以！不可以搞混了！
   ```

   

成功之后，通过以下来测试一下

```bash
[vbirdtsai@clientlinux ~]$ scp /etc/hosts* dmtsai@192.168.100.254:~
hosts                                        100%  187     0.2KB/s   00:00
hosts.allow                                  100%  161     0.2KB/s   00:00
hosts.deny                                   100%  347     0.3KB/s   00:00
# 你会发现，原本会出现的那个密码提示数据不会出现了喔！

[vbirdtsai@clientlinux ~]$ ssh dmtsai@192.168.100.254 "ls -l"
-rw-r--r--. 1 dmtsai dmtsai 196 2011-07-25 13:09 hosts
-rw-r--r--. 1 dmtsai dmtsai 370 2011-07-25 13:09 hosts.allow
-rw-r--r--. 1 dmtsai dmtsai 460 2011-07-25 13:09 hosts.deny
-rw-r--r--. 1 dmtsai dmtsai 416 2011-07-25 13:05 id_rsa.pub
# 确实有复制到对方去了！有显示出正确的远程数据哩！
```



建立密钥系统的步骤谨记：

* Client 必须制作出 Public & Private 这两把 Keys，且 Private_key 需要放到 `~/.ssh` 内
* Server 必须要有 PublicKey，且放置到用户家目录下的 `~/.ssh/authorized_keys`，同时目录的权限 (.ssh/) 必须是 700 而且文件权限必须是 644，同时文件的拥有者与群组必须与该账号吻合。

## 11.5 以rsync进行同步镜像备份

rsync 作为一个相当棒的异地备份系统的备份指令。

rsync 传输方式至少可以用三种方式来运作：

* 在本机上直接运行，用法与 cp 几乎一模一样

  ```bash
  #将 /etc/ 的数据备份到 /tmp/etc 内
  rsync -av /etc /tmp
  ```

* 通过 rsh 或 ssh 的方式在 Server/Client 之间进行传输数据

  ```bash
  #将rsh.server的 /etc/ 备份到本机的 /tmp 内
  rsync -av -e ssh user@rsh.server:/etc /tmp
  ```

* 直接通过 rsync 提供的服务(daemon)来传输，此时rsync主机需要启动 873 端口

  * 必须在 server 端启动 rsync，看 `/etc/xinetd.d/rsync` 即可
  * 编辑 `/etc/rsyncd.conf` 配置文件
  * 设定好 client 端联机的密码数据
  * 在 client 端可以利用 `rsync -av user@hostname::/dir/path /local/path`



三种模式的差异在于有没有冒号（:），本地传输不需要冒号；透过 ssh 或 rsh 时，需要一个冒号`;`，如果是通过 rsync daemon的话，需要两个冒号 `::`

```bash
[root@www ~]# rsync [-avrlptgoD] [-e ssh] [user@host:/dir] [/local/path]
选项与参数：
-v ：观察模式，可以列出更多的信息，包括镜像时的档案档名等；
-q ：与 -v  相反，安静模式，略过正常信息，仅显示错误讯息；
-r ：递归复制！可以针对『目录』来处理！很重要！
-u ：仅更新 (update)，若目标档案较新，则保留新档案不会覆盖；
-l ：复制链接文件的属性，而非链接的目标源文件内容；
-p ：复制时，连同属性 (permission) 也保存不变！
-g ：保存源文件的拥有群组；
-o ：保存源文件的拥有人；
-D ：保存源文件的装置属性 (device)
-t ：保存源文件的时间参数；
-I ：忽略更新时间 (mtime) 的属性，档案比对上会比较快速；
-z ：在数据传输时，加上压缩的参数！
-e ：使用的信道协议，例如使用 ssh 通道，则 -e ssh
-a ：相当于 -rlptgoD ，所以这个 -a 是最常用的参数了！
更多说明请参考 man rsync 的解说！
```

```bash
# 1. 将 /etc 的数据备份到 /tmp 底下：
[root@www ~]# rsync -av /etc /tmp
....(前面省略)....
sent 21979554 bytes  received 25934 bytes  4000997.82 bytes/sec
total size is 21877999  speedup is 0.99
[root@www ~]# ll -d /tmp/etc /etc
drwxr-xr-x. 106 root root 12288 Jul 26 16:10 /etc
drwxr-xr-x. 106 root root 12288 Jul 26 16:10 /tmp/etc <==瞧！两个目录一样！
# 第一次运作时会花比较久的时间，因为首次建立嘛！如果再次备份呢？

[root@www ~]# rsync -av /etc /tmp
sent 55716 bytes  received 240 bytes  111912.00 bytes/sec
total size is 21877999  speedup is 390.99
# 比较一下两次 rsync 的传输与接受数据量，你就会发现立刻就跑完了！
# 传输的数据也很少！因为再次比对，仅有差异的档案会被复制。

# 2. 利用 student 的身份登入 clientlinux.centos.vbird 将家目录复制到本机 /tmp
[root@www ~]# rsync -av -e ssh student@192.168.100.10:~ /tmp 
student@192.168.100.10's password:  <==输入对方主机的 student 密码
receiving file list ... done
student/
student/.bash_logout
....(中间省略)....
sent 110 bytes  received 697 bytes  124.15 bytes/sec
total size is 333  speedup is 0.41

[root@www ~]# ll -d /tmp/student
drwx------. 4 student student 4096 Jul 26 16:52 /tmp/student
# 瞧！这样就做好备份啦！很简单吧！
```



:question: 在 clientlinux.centos.vbird (192.168.100.10) 上面，使用 vbirdtsai 的身份建立一只脚本，这只脚本可以在每天的 2:00am 主动的以 rsync 配合 ssh 取得 www.centos.vbird (192.168.100.254) 的 /etc, /root, /home 三个目录的镜像到 clientlinux.centos.vbird 的 /backups/ 底下。

```bash
# 1. 在 clientlinux.centos.vbird 将公钥档复制给 www.centos.vbird 的 root
[vbirdtsia@clientlinux ~]$ scp ~/.ssh/id_rsa.pub root@192.168.100.254:~

# 2. 在 www.centos.vbird 上面用 root 建置好 authorized_keys
[root@www ~]# ls -ld id_rsa.pub .ssh
-rw-r--r--. 1 root root  416 Jul 26 16:59 id_rsa.pub <==有公钥档
drwx------. 2 root root 4096 Jul 25 11:44 .ssh       <==有 ssh 的相关目录

[root@www ~]# cat id_rsa.pub >> ~/.ssh/authorized_keys
[root@www ~]# chmod 644 ~/.ssh/authorized_keys

# 3. 在 clientlinux.centos.vbird 上面撰写 script 并测试执行：
[vbirdtsai@clientlinux ~]$ mkdir ~/bin ; vim ~/bin/backup_www.sh
#!/bin/bash
localdir=/backups
remotedir="/etc /root /home"
remoteip="192.168.100.254"

[ -d ${localdir} ] || mkdir ${localdir}
for dir in ${remotedir}
do
        rsync -av -e ssh root@${remoteip}:${dir} ${localdir}
done

[vbirdtsai@clientlinux ~]$ chmod 755 ~/bin/backup_www.sh
[vbirdtsai@clientlinux ~]$ ~/bin/backup_www.sh
# 上面在测试啦！第一次测试可能会失败，因为鸟哥忘记 /backups 需要 root
# 的权限才能够建立。所以，请您再以 root 的身份去 mkdir 及 setfacl 吧！

# 4. 建立 crontab 工作
[vbirdtsai@clientlinux ~]$ crontab -e
0 2 * * * /home/vbirdtsai/bin/backup_www.sh
```



# 第19章 DNS服务器

DNS 系统是以所谓的阶层式管理。**每个上一层的DNS服务器所记录的信息，只有其下一层的主机名而已。**



通过 dig 实现 `.tw -> .edu.tw -> .ksu.edu.tw -> www.ksu.edu.tw` ，分析每个查询阶段的 DNS 服务器有哪几台？

```bash
> dig +trace www.ksu.edu.tw
; <<>> DiG 9.3.6-P1-RedHat-9.3.6-16.P1.el5 <<>>+trace www.ksu.edu.tw
;; global options:  printcmd
.                       486278  IN      NS      a.root-servers.net.
.                       486278  IN      NS      b.root-servers.net.
....(底下省略)....
# 上面的部分在追踪 . 的服务器，可从 a ~ m.root-servers.net.
;; Received 500 bytes from 168.95.1.1#53(168.95.1.1) in 22 ms

tw.                     172800  IN      NS      ns.twnic.net.
tw.                     172800  IN      NS      a.dns.tw.
tw.                     172800  IN      NS      b.dns.tw.
....(底下省略)....
# 上面的部分在追踪 .tw. 的服务器，可从 a ~ h.dns.tw. 包括 ns.twnic.net.
;; Received 474 bytes from 192.33.4.12#53(c.root-servers.net) in 168 ms

edu.tw.                 86400   IN      NS      a.twnic.net.tw.
edu.tw.                 86400   IN      NS      b.twnic.net.tw.
# 追踪 .edu.tw. 的则有 7 部服务器
;; Received 395 bytes from 192.83.166.11#53(ns.twnic.net) in 22 ms

ksu.edu.tw.             86400   IN      NS      dns2.ksu.edu.tw.
ksu.edu.tw.             86400   IN      NS      dns3.twaren.net.
ksu.edu.tw.             86400   IN      NS      dns1.ksu.edu.tw.
;; Received 131 bytes from 192.83.166.9#53(a.twnic.net.tw) in 22 ms

www.ksu.edu.tw.         3600    IN      A       120.114.100.101
ksu.edu.tw.             3600    IN      NS      dns2.ksu.edu.tw.
ksu.edu.tw.             3600    IN      NS      dns1.ksu.edu.tw.
ksu.edu.tw.             3600    IN      NS      dns3.twaren.net.
;; Received 147 bytes from 120.114.150.1#53(dns2.ksu.edu.tw) in 14 ms
```

## DNS数据库的记录：正解、反解

正解：主机名查询到IP

反解：IP反解析到主机名



## Clinent 端相关配置文件

`/etc/hosts` Hostname 对应 IP 的文件

`/etc/resolv.conf` ISP 的 DNS 服务器 IP 记录处

`/etc/nsswitch.conf` 决定使用 `/etc/hosts` 还是 `/etc/resolv.conf` 的设置



### host

```bash
host [-a] FQDN [server]
host -l domain [server]
选项与参数：
-a ：代表列出该主机所有的相关信息，包括 IP、TTL 与除错讯息等等
-l ：若后面接的那个 domain 设定允许 allow-transfer 时，则列出该 domain 
     所管理的所有主机名对应数据！
server：这个参数可有可无，当想要利用非 /etc/resolv.conf 内的 DNS 主机
        来查询主机名与 IP 的对应时，就可以利用这个参数了！
```



```bash
# 1. 使用默认值来查出 linux.vbird.org 的 IP
> host linux.vbird.org
linux.vbird.org has address 140.116.44.180             <==这是 IP
linux.vbird.org mail is handled by 10 linux.vbird.org. <==这是 MX (后续章节说明)

# 2. 查出 linux.vbird.org 的所有重要参数
> host -a linux.vbird.org
Trying "linux.vbird.org"
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 56213
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 0

;; QUESTION SECTION:
;linux.vbird.org.               IN      ANY

;; ANSWER SECTION:
linux.vbird.org.        145     IN      A       140.116.44.180

;; AUTHORITY SECTION:
vbird.org.              145     IN      NS      dns.vbird.org.
vbird.org.              145     IN      NS      dns2.vbird.org.

Received 86 bytes from 168.95.1.1#53 in 15 ms  <==果然是从 168.95.1.1 取得的资料
# 看样子，不就是 dig 的输出结果？所以，我们才会说，使用 dig 才是王道！

# 3. 强制以 139.175.10.20 这部 DNS 主机来查询
> host linux.vbird.org 139.175.10.20
Using domain server:
Name: 139.175.10.20
Address: 139.175.10.20#53
Aliases:

linux.vbird.org has address 140.116.44.180
linux.vbird.org mail is handled by 10 linux.vbird.org.
```



### nslookup

```bash
> nslookup [FQDN] [server]
> nslookup
选项与参数：
1. 可以直接在 nslookup 加上待查询的主机名或者是 IP ，[server] 可有可无；
2. 如果在 nslookup 后面没有加上任何主机名或 IP ，那将进入 nslookup 的查询功能
   在 nslookup 的查询功能当中，可以输入其他参数来进行特殊查询，例如：
   set type=any ：列出所有的信息『正解方面配置文件』
   set type=mx  ：列出与 mx 相关的信息！
```

```bash
# 1. 直接搜寻 mail.ksu.edu.tw 的 IP 信息 
[root@www ~]# nslookup mail.ksu.edu.tw
Server:         168.95.1.1
Address:        168.95.1.1#53  <==还是请特别注意 DNS 的 IP 是否正确！

Non-authoritative answer:
Name:   mail.ksu.edu.tw
Address: 120.114.100.20        <==回报 IP 给你啰！
```



nslookup 可单纯的将 hostname 与 IP 对应列出而已，不过，还是会将查询的 DNS 主机的 IP 列出来的！ 如果想要知道更多详细的参数，那可以直接进入 nslookup 这个软件的操作画面中，如下范例：



```bash
> nslookup  <==进入 nslookup 查询画面
> 120.114.100.20         <==执行反解的查询
> www.ksu.edu.tw         <==执行正解的查询
# 上面这两个仅列出正反解的信息，没有啥了不起的地方啦！
> set type=any           <==变更查询，不是仅有 A，全部信息都列出来
> www.ksu.edu.tw
Server:         168.95.1.1
Address:        168.95.1.1#53

Non-authoritative answer:
Name:   www.ksu.edu.tw
Address: 120.114.100.101  <==这是答案

Authoritative answers can be found from: <==这是相关授权 DNS 说明
ksu.edu.tw      nameserver = dns2.ksu.edu.tw.
ksu.edu.tw      nameserver = dns1.ksu.edu.tw.
dns1.ksu.edu.tw internet address = 120.114.50.1
dns2.ksu.edu.tw internet address = 120.114.150.1
```



### dig

```bash
dig [options] FQDN [@server]
选项与参数：
@server ：如果不以 /etc/resolv.conf 的设定来作为 DNS 查询，可在此填入其他的 IP
options：相关的参数很多，主要有 +trace, -t type 以及 -x 三者最常用
  +trace ：就是从 . 开始追踪，在 19.1.2 里面谈过了！回头瞧瞧去！
  -t type：查询的数据主要有 mx, ns, soa 等类型，相关类型 19.4 来介绍
  -x     ：查询反解信息，非常重要的项目！
```

```bash
# 1. 使用默认值查询 linux.vbird.org 吧！
[root@www ~]# dig linux.vbird.org
; <<>> DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 <<>> linux.vbird.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 37415
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 0

;; QUESTION SECTION:     <==提出的问题的部分
;linux.vbird.org.               IN      A

;; ANSWER SECTION:       <==主要的回答阶段
linux.vbird.org.        600     IN      A       140.116.44.180

;; AUTHORITY SECTION:    <==其他与此次回答有关的部分
vbird.org.              600     IN      NS      dns.vbird.org.
vbird.org.              600     IN      NS      dns2.vbird.org.

;; Query time: 9 msec
;; SERVER: 168.95.1.1#53(168.95.1.1)
;; WHEN: Thu Aug  4 14:12:26 2011
;; MSG SIZE  rcvd: 86
```

```bash
# 2. 查询 120.114.100.20 的反解信息结果
[root@www ~]# dig -x 120.114.100.20
; <<>> DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 <<>> -x 120.114.100.20
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 60337
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 3, ADDITIONAL: 3

;; QUESTION SECTION:
;20.100.114.120.in-addr.arpa.   IN      PTR

;; ANSWER SECTION:
20.100.114.120.in-addr.arpa. 3600 IN    PTR     mail-out-r2.ksu.edu.tw.
20.100.114.120.in-addr.arpa. 3600 IN    PTR     mail-smtp-proxy.ksu.edu.tw.
20.100.114.120.in-addr.arpa. 3600 IN    PTR     mail.ksu.edu.tw.

;; AUTHORITY SECTION:
100.114.120.in-addr.arpa. 3600  IN      NS      dns1.ksu.edu.tw.
100.114.120.in-addr.arpa. 3600  IN      NS      dns3.twaren.net.
100.114.120.in-addr.arpa. 3600  IN      NS      dns2.ksu.edu.tw.

;; ADDITIONAL SECTION:
dns1.ksu.edu.tw.        3036    IN      A       120.114.50.1
dns2.ksu.edu.tw.        2658    IN      A       120.114.150.1
dns3.twaren.net.        449     IN      A       211.79.61.47

;; Query time: 29 msec
;; SERVER: 168.95.1.1#53(168.95.1.1)
;; WHEN: Thu Aug  4 14:17:58 2011
;; MSG SIZE  rcvd: 245
```

**反解的查询目标竟然从 120.114.100.20 变成了 20.100.114.120.in-addr.arpa.** 



### whois

```bash
[root@www ~]# whois [domainname]  <==注意啊！是 domain 而不是 hostname
[root@www ~]# whois centos.org
[Querying whois.publicinterestregistry.net]
[whois.publicinterestregistry.net]
# 这中间是一堆 whois 服务器提供的讯息告知！底下是实际注册的数据
Domain ID:D103409469-LROR
Domain Name:CENTOS.ORG
Created On:04-Dec-2003 12:28:30 UTC
Last Updated On:05-Dec-2010 01:23:25 UTC
Expiration Date:04-Dec-2011 12:28:30 UTC  <==记载了建立与与失效的日期
Sponsoring Registrar:Key-Systems GmbH (R51-LROR)
Status:CLIENT TRANSFER PROHIBITED
Registrant ID:P-8686062
Registrant Name:CentOS Domain Administrator
Registrant Organization:The CentOS Project
Registrant Street1:Mechelsesteenweg 170
# 底下则是一堆联络方式，鸟哥将它取消了，免得多占篇幅～
```

whois 这个指令可以查询到当初注册这个 domain 的用户的相关信息





# 第20章 WWW服务器

## WWW服务器基本配置

PHP是挂在Apache下面执行的一个模块，PHP需要支持MySQL的模块

```php
yum install httpd mysql mysql-server php php-mysql
```



**Apache 2.2.x的配置文件**

* `/etc/httpd/conf/httpd.conf` 主要配置文件

* `/etc/httpd/conf.d/*.conf` 额外的参数文件。可以自定义参数，例如`/etc/httpd/conf.d/vbird.conf` 必须是 `.conf` 文件后缀，会被合并到主配置文件
* `/usr/lib64/httpd/modules/` 和 `/etc/httpd/modules/` Apache的外挂模块
* `/var/www/html/` 网站默认目录
* `/var/www/cgi-bin/` 默认给一些可执行的CGI(网页程序)程序放置的目录 `http://localhost/cgi-bin/`可以访问
* `/var/log/httpd/` 默认的Apache日志文件目录
* `/usr/sbin/apachectl` Apache的主要执行文件，是一个shell
* `/usr/sbin/httpd` Apache二进制执行文件
* `/usr/bin/htpasswd` Apache密码保护。访问某些网页的时候，需要输入账号和密码，基本的保护方式 是一个二进制执行文件



**MySQL 重要目录与文件**

* `/etc/my.cnf` MySQL主要配置文件，可进行数据库的优化或者参数的制定
* `/var/lib/mysql/` 目录是 MySQL 数据库文件存储的位置



**PHP 重要文件**

* `/etc/httpd/conf.d/php.conf` 此文件会在 Apache 重启时被读取，并引入到 httpd.conf 中

* `/etc/php.ini` PHP的主要配置文件，包括 PHP 能不能允许用户上传文件？允许低安全性的标志
* `/usr/lib64/httpd/modules/libphp5.so` PHP这个软件提供给 Apache 使用的模块。

* `/etc/php.d/mysql.ini` `/usr/lib64/php/modules/mysql.so `PHP是否支持MySQL的接口，由 php-mysql 软件提供
* `/usr/bin/phpize` `/usr/include/php` 未来安装 PHP 扩展，这个文件和目录需要存在，否则无法编译成功。是由 php-devel 软件提供



### Apache 基本设置

```bash
# 合法的主机名
> vim /etc/hosts
127.0.0.1  localhost
```



**针对服务器环境的设置项目**

> 响应给客户端的服务器软件版本、主机名、服务器配置文件顶层目录

```bash
> vim /etc/httpd/conf/httpd.conf

ServerRoot "/etc/httpd"  #最顶层目录 chroot.包括logs modules等的数据放置在目录下

# 放置 PID 的文件，方便 Apache 软件的管理 + ServerRoot目录   /etc/httpd/run/httpd.pid
PidFile run/httpd.pid

# 无论接收或发送 当持续连接等待超过60秒则改次连接就中断
timeout 60

# 是否允许持续性的连接
KeepAlive On
MaxKeepAliveRequests 500  #当KeepAlive设置为On时,这个数值代表该次连接能够传输的最大传输数量
KeepAliveTimeout 15  #当KeepAlive设置为On时,该次连接在最后一次传输后等待延迟的秒数(超过上述秒数连接中断)


# 下面两个 prefork、worker 与内存有关
<IfModule prefork.c>   
StartServers       8     #启动 httpd 时,唤醒几个 PID 来处理服务
MinSpareServers    5     #最小的预备使用的 PID 数量
MaxSpareServers   20     #最大的预备使用的 PID 数量
ServerLimit      256     #服务器的限制
MaxClients       256     #最多容许多少个客户端同时连接到 httpd 的意思
MaxRequestsPerChild  4000
</IfModule>

<IfModule worker.c>
StartServers         4
MaxClients         300
MinSpareThreads     25
MaxSpareThreads     75
ThreadsPerChild     25
MaxRequestsPerChild  0
</IfModule>
```



这个 **MaxClients** 设置值可以控制同时连接 WWW 服务器的总连接要求数量，可以将其看成最高实时在线人数。不是越高越好，会消耗物理内存。

Apache到底使用哪个模块？prefork还是worker? CentOS将这两个模块放到不同的执行文件中，分别是：

* `/usr/sbin/httpd` 使用 prefork 模块
* `/usr/sbin/httpd.worker` 使用 worker 模块

配置文件在 `/etc/sysconfig/httpd` 里，默认使用 prefork 模块，可以修改 /etc/sysconfig/httpd 来使用 worker 模块



```bash
# 监听端口
Listen 80 

# 加载相应扩展模块 有很多的外挂模块
LoadModule alias_module modules/mod_alias.so

# 读取 /etc/httpd/conf.d/*.conf 下的设置文件
Include conf.d/*.conf

# httpd 运行的用户和组所属
User apache
Group apache

# 管理员的 E-mail 当网站出现问题时,错误信息会显示的联系邮箱
ServerAdmin  admin@i9u.cc

# 设置主机名 hostname 需要可以用主机名找到IP DNS或 etc/hosts 
ServerName   www.i9u.cc
# 是否只使用标准主机名 如果为On 则只使用上边指定的 ServerName 的值
UseCanonicalName Off
```

可以将 自己的额外设置指定到 `/etc/httpd/conf.d/*.conf` 



**针对语言编码的参数设置**

```bash
#强制使用 UTF-8 编码
AddDefaultCharset UTF-8
```



**网页首页及目录相关全县的设置 DocumentRoot 与 Directory**

```bash
# Apache 允许 Internet 对我们的数据进行浏览，必须要针对可被浏览的目录进行权限相关设置，这就是 <Directory> 设置值的作用

# WWW 服务器主网页放置的目录
DocumentRoot '/var/www/html'

# WWW 服务器默认环境 针对 / 的设置
<Directory />
	Options FollowSymLinks
	AllowOverride None
</Directory>

# 针对特定目录的限制
<Directory '/var/www/html'>
	Options Indexes FollowSymLinks   #建议去掉 Indexes
	AllowOverride None
	Order allow,deny  #默认是 deny 不可浏览
	Allow from all  #allow优先处理,因此全部客户端皆可浏览
</Directory>
```

针对 `/var/www/html` 目录设置权限，首页所在目录的权限



Options 目录参数

* Indexes  在目录下找不到首页文件(index.html)，就显示整个目录下的文件名
* FollowSymLinks  让链接文件可生效
* ExecCGI  让此目录拥有执行 CGI 程序的权限
* Includes  让一些 Server-Side Include 程序可以运行
* MultiViews  多国语言支持



AllowOverride 允许的覆盖参数功能

表示是否允许额外配置文件 .htaccess 的某些参数覆盖。

Apache 默认可以让用户以目录下面的 .htaccess 文件内覆盖 <Directory> 内的某些功能参数。这个项目则是规定 .htaccess 可以覆盖的权限类型

* ALL  全部的权限均可覆盖
* AuthConfig  仅有网页认证（账号与密码）可覆盖
* Indexes  仅允许 Indexes 方面的覆盖
* Limits  允许用户利用 Allow、Deny 与 Order 管理可浏览的权限
* None  不可覆盖，让 .htaccess 文件失效



Order、Allow、Deny 能否登陆浏览的权限

决定此目录是否可被 Apache 的 PID 所浏览的权限设置

* deny,allow  以 deny 优先处理，但没有写入规则的则默认为 allow
* allow,deny  以 allow 优先处理，但没有写入规则的则默认为 deny

在默认环境中，因为是 allow,deny 所以默认是 deny（不可浏览），下一行有个 Allow from all，因为 allow 优先处理，因此全部客户端皆可浏览。

---

```bash
# 默认首页文件 
# 如果都存在,则按照 DirectoryIndex 后面的文件名参数,越前面的越优先读取 
# 如果没有首页 则与 Options 里边的 Indexes 有关
DirectoryIndex index.html index.htm
```



```bash
# Alias 网址延伸 实际 Linux 目录
Alias /icons/ "/var/www/icons/"   # 制作一个目录别名 相当于快捷方式
<Directory "/var/www/icons">
    Options Indexes MultiViews
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>
```

Alias 可以制作出类似链接文件。当输入 `http://localhost/icons` 时，其实网站根目录 `/var/www/html` 并没有 icons 这个目录，由于 Alias 关系，会让该网址直链链接到 `/var/www/icons/` 下。



```bash
# ScriptAlias 网址延伸 实际 Linux 目录
ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"
<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Order allow,deny
    Allow from all
</Directory>
```

ScriptAlias 以 ScriptAlias（可执行脚本的别名）为设置值。这个设置值可以指定该目录下面为“具有ExecCGI能力”的目录所在。

可以将类似 Open webmail 的程序放在 /var/www/cgi-bin 目录下，不必额外设置其他目录来放置 CGI 程序



### PHP 的默认参数

PHP 是 Apache 当中的一个模块，Apache 很智能的将重要模块拆出来放置到 `/etc/httpd/conf.d/*.conf` 文件中了。

```bash
> ll /etc/httpd/conf.d/
-rw-r--r--. 1 root root 674 3月  22 2017 php.conf         #PHP模块的设置

#默认的页面 /var/www/error/noindex.html
-rw-r--r--. 1 root root 299 2月  19 2018 welcome.conf     #默认的首页欢迎信息,如果首页不存在时的欢迎画面
```

```bash
> vim /etc/httpd/conf.d/php.conf

# 根据不同的 PID 模式 选择不同的 PHP 运行模块
<IfModule prefork.c>  
  LoadModule php5_module modules/libphp5.so
</IfModule>
<IfModule worker.c>
  LoadModule php5_module modules/libphp5-zts.so
</IfModule>

AddHandler php5-script .php   #扩展名一定是 .php 结尾
AddType text/html .php        #.php结尾的文件是纯文本文件
DirectoryIndex index.php      #首页文件名增加 index.php
#AddType application/x-httpd-php-source .phps 
```



**PHP安全方面的设定**

PHP的配置文件在 `/etc/php.ini` 

```bash
> vim /etc/php.ini

# 设置为 Off
register_globals = Off   #提交过来的表单数据注册为全局变量 https://www.cnblogs.com/wawahaha/p/4820591.html

# 是否将 PHP 程序的错误记录起来 将重复的错误数据忽略掉
log_errors = On
ignore_repeated_errors = On
ignore_repeated_source = On

# 当程序出现问题时,是否在浏览器上显示相关错误信息
# /var/log/httpd/error_log 日志文件查阅
display_errors = Off
display_startup_errors = Off
```



**PHP提供的上传容量限制**

```bash
> vim /etc/php.ini
post_max_size = 20M   #post数据最大
file_uploads = On     #开启文件长传
upload_max_filesize = 16M  #文件最大值
memory_limit = 128M  #PHP 可用内存容量
```

post_max_size > upload_max_filesize.  因为 post表单数据除了包含文件，还包含其他数据



### 启动 WWW 服务与测试 PHP 模块

```bash
/etc/init.d/httpd start
/etc/init.d/httpd configtest #测试配置文件语法

#Apache提供的shell
/usr/sbin/apachectl start
/usr/sbin/apachectl stop
```



### MySQL 基本设定

在启动 MySQL 前系统没有建立任何数据库，只有初次启动。MySQL 后，系统才会针对数据库进行初始化的建立。

数据库的位置：`/var/lib/mysql/` 目录



**启动 MySQL**

```bash
/etc/init.d/mysqld start

#初始化没有密码
mysql -u root
```

设置 root 密码

```bash
# 设置root密码
mysqladmin -u root password 'you.password'

# 新建用户并设置密码
mysqladmin -u root -p

create database vbirddb;
grant all privileges on vbirddb.* to smiler@localhost identified by '111111'
flush privileges;

# 查看有没有这个用户
select * from user where user = 'smiler'
```



**效率调优 /etc/my.cnf**

```bash
> vim /etc/my.cnf

[mysqld]
default-storage-engine=innodb
# 关于目录数据与语言的设置
default-character-set   = utf8   
port                    = 3306
skip-locking
# 關於記憶體的設定，注意，記憶體的簡單計算方式為：
# key_buffer + (sort_buffer + read_buffer ) * max_connection
# 且總量不可高於實際的實體記憶體量！所以，我底下的資料應該是 OK 的
# 128 + (2+2)*150 = 728MB
key_buffer              = 128M
sort_buffer_size        = 2M
read_buffer_size        = 2M
join_buffer_size        = 2M
max_connections         = 150
max_connect_errors      = 10
read_rnd_buffer_size    = 4M
max_allowed_packet      = 4M
table_cache             = 1024
myisam_sort_buffer_size = 32M
thread_cache            = 16
query_cache_size        = 16M
tmp_table_size          = 64M
# 由連線到確定斷線的時間，原本是 28800 (sec) ，約 8 小時，我將他改為 20 分鐘！
wait_timeout            = 1200
thread_concurrency      = 8
innodb_data_file_path = ibdata1:10M:autoextend
innodb_buffer_pool_size = 128M
innodb_additional_mem_pool_size = 32M
innodb_thread_concurrency = 16

datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
user=mysql
symbolic-links=0

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
```



**MySQL root 密码遗忘**

将 MySQL 关闭，将 `/var/lib/mysql/*` 目录内的数据删除掉，然后再重新启动 MySQL，那么 MySQL 数据库会重建，而且 root 也没有密码了。



## Apache服务器的高级设定

### 用户家目录个人网站

```bash
> vim /etc/httpd/conf/httpd.conf

# 找到如下的設定項目，大約在 366 行左右：
<IfModule mod_userdir.c>
    UserDir disable
    #UserDir public_html
</IfModule>
# 將他改成如下的情況喔！
<IfModule mod_userdir.c>
    #UserDir disable
    UserDir www
</IfModule>
```

### CGI 执行

```bash
> vim /etc/httpd/conf/httpd.conf

# 找到底下這一行，大約在 797 行左右啦：
#AddHandler cgi-script .cgi
# 將他改成底下的模樣，讓附檔名為 .pl 的檔案也能執行喔！
AddHandler cgi-script .cgi .pl

# 然後加入底下這幾行來決定開放某個目錄的 CGI 執行權限。
<Directory "/var/www/html/cgi">
    Options +ExecCGI
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>

ScriptAlias /perl/ "/var/www/perl/"
```

### 浏览权限的设定操作 Order、Limit

:question: 再看看

限制客户端对 WWW 的连接。用 Apache 内置的 Order 来处理，搭配 allow、deny

* Order deny,allow  以deny优先处理，没有写入规则的默认为allow. 拒绝所有，开放特定
* Order allow,deny  以allow优先处理，没有写入规则的默认为deny. 开放所有，拒绝特定
* 如果 allow 与 deny 的规则当中有重复的，以默认的的情况（Order的规范）为主



```bash
# 首页目录想让 192.168.1.101 及 政府部门 无法连接，其他可以连接   开放所有，拒绝特定
> vim /etc/httpd/conf/httpd.conf
<Directory "/var/www/html">
    Options FollowSymLinks
    AllowOverride None
    Order allow,deny
    Allow from all
    Deny from 192.168.1.101  <==約在 344 行新增底下兩行！
    Deny from .gov.tw
</Directory>
```



### .htaccess 与 认证网页设置

保护 Apache 本身的数据方面，除了上述的 Order 以及 Limit 之外，还可以使用 .htaccess

Order 与 Limit 主要针对 IP网络 或者是 主机名 来管理。



我们能够通过外部的文件来取代设置在 httpd.conf 内的参数，该文件能即时生效，不需要重启 Apache。

通过 httpd.conf 内的 **AllowOverride** 参数，配合 .htaccess 文件的设置可以达到。

![](http://cn.linux.vbird.org/linux_server/0360apache_files/protect.gif)



* 主配置文件 httpd.conf 的修改：先在 httpd.conf 主配置文件中先以 AllowOverride 指定某个目录下的 .htaccess 有哪些能够进行取代的参数，一般有 AuthConfig、Options 等，然后重启
* .htaccess 放置到目录
* .htaccess 修改：设置完立即生效，不用重启 Apache。因为该文件内容是“当有客户端浏览到该目录时，该文件才会被用来取代原来的设置”



```bash
> vim /etc/httpd/conf/httpd.conf

AccessFileName .htaccess
<Files ~ "^\.ht">
    Order allow,deny
    Deny from all
    Satisfy All
</Files>

# 在某個不受影響的地方加入這一段：
<Directory "/var/www/html/protect">
    AllowOverride AuthConfig
    Order allow,deny
    Allow from all
</Directory>
```

### 虚拟主机的设定

多个主机名对应不同的主网页目录（DocumentRoot参数）  用 dig 软件查验 IP 的话，发现两个网址指向同一个 IP

将虚拟主机的设置建立一个新的文件 在 /etc/httpd/conf.d/*.conf 当中

```bash
> vim /etc/httpd/conf.d/virtual.conf
# 底下這一行在規定『本機任何介面的 port 80 所指定的虛擬主機』的意思。
NameVirtualHost *:80

# 先針對兩個多出來的可瀏覽目錄進行權限方面的規範啊！
<Directory "/var/www/www">
    Options FollowSymLinks
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>

# 針對三部主機的 DocumentRoot 進行定！
<VirtualHost *:80>
    ServerName    linux.centos.vbird
    DocumentRoot  /var/www/html
</VirtualHost>
<VirtualHost *:80>
    ServerName    www.centos.vbird
    DocumentRoot  /var/www/www
    CustomLog     /var/log/httpd/www.access_log combined
    # 不同的主頁可以指定不同的登錄檔資訊，這樣比較好 debug 與分析啦！
</VirtualHost>
<VirtualHost *:80>
    ServerName    ftp.centos.vbird
    DocumentRoot  /var/ftp
</VirtualHost>

# CustomLog 表示向 www.centos.vbird 要求数据的记录都会写入 /var/log/httpd/www.access_log 中而不是默认的 /var/log/httpd/access_log
```



### 日志

* /var/log/httpd/access_log  客户端正常要求的记录信息
* /var/log/httpd/error_log   用户错误要求的数据，包括服务器设置错误的信息等

/var/log/httpd/error_log 可以处理很多设置错误的情况，如网页找不到、文件权限设置错误、密码文件文件名填错等。

/var/log/httpd/access_log 分析哪个网页被访问了以及访问频率。



---

1. Alias 和 ScriptAlias 的区别？
2. order 和 deny 那一块
3. 伪静态的配置流程





---

Apache 的 Order Allow,Deny 详解

apache会按照 order 决定最后使用哪一条规则。order决定的 **最后规则** 非常重要

```bash
# 虽然第二句allow允许了访问，但由于在order中allow不是最后规则，因此还需要看有没有deny规则，于是到了第三句，符合ip1和ip2的访问就被禁止了
Order Allow,Deny
Allow from all
Deny from ip1 ip2
```

影响结果的有两点

1. order 语句中 allow、deny 的先后顺序
2. allow、deny 语句中各自包含的范围



在Apache的配置文件中，`Order`指令用于控制`Allow`指令和`Deny`指令的生效顺序。例如，`Order Allow,Deny`表示当前配置段中的`Allow`指令先生效，`Deny`指令后生效。

在Apache中，`Allow`指令和`Deny`指令在同一配置段中都可以有多条。不过，对于`Allow`和`Deny`指令而言，如果先生效的指令与后生效的指令的作用范围存在冲突，则起冲突的作用范围部分以 **后生效的指令** 为准。

[order allow,deny]: https://www.cnblogs.com/top5/archive/2009/09/22/1571709.html
[apche里的order]: http://www.nowamagic.net/academy/detail/1225509
[apache目录访问权限配置]: https://codeplayer.vip/p/j7sc8
[apache的order allow,deny]: https://www.jb51.net/article/77225.htm



# 第21章 FTP服务器

## FTP数据传输原理

### 功能简介

**不同等级的用户身份 user、guest、anonymous**

依据用户身份的不同，分别是：

1.实体用户，real user；权限比较完整

2.访客，guest；

3.匿名用户，anonymous 只有下载功能



FTP可以使用系统的 syslogd 进行数据的记录，包括用户曾经使用过的命令与用户传输数据的记录，很轻松在 /var/log 里找到各项日志信息



**限制用户活动的目录 change root 简称 chroot**

FTP 可以限制用户仅能在自己的用户主目录当中活动。如此，用户无法离开自己的用户主目录，而且登陆 FTP 后，显示的根目录就是用户主目录的内容，这种环境称之为 change root ，简称 chroot ，即改变根目录的意思。



### 主动式连接模式

FTP传输使用的是 TCP 数据包协议，建立连接前需要进行三次握手。

FTP服务器使用了两个连接，分别是命令通道与数据流通道，都要进行三次握手。下面以FTP默认的主动式(Active)连接来说明。

![](http://cn.linux.vbird.org/linux_server/0410vsftpd_files/connect_active.gif)



* 建立命令通道的连接

  客户端随机取一个大于1024以上的端口（Port AA）来与 FTP 服务器端的 port 21 实现连接，三次握手。实现连接后，客户端可以通过这个连接对 FTP 服务器执行命令：查询文件名、下载、上传等命令

* 通知 FTP 服务器端使用 Active 且告知连接的端口号

  FTP 服务器端口 21 主要用于命令的执行。当传输数据流时，不使用这个连接。客户端需要数据的情况下，**告知服务器用什么方式来连接**，如果是主动式（Active）连接时，**客户端会先随机开启一个端口（port BB）**，且通过命令通道告知 FTP服务器 这两个信息，等待 FTP服务器的连接。

* FTP 服务器主动向客户端连接

  FTP服务器收到客户端的需求后，主动由 20 端口向客户端的 port BB 连接，三次握手。此时，FTP的客户端与服务端会建立两条连接，分别用于命令的执行与数据的传输。默认的FTP服务器端使用的主动连接端口是 port 20                    



数据传输通道是在**有数据传输的行为时才会建立的通道**，并不是一开始连接到 FTP 服务器就立刻建立的通道。



主动式连接使用的端口号

* 命令通道的 ftp   port 21
* 数据传输的 ftp-data   port 20

两者的连接发起端不一样。port 21 端口主要接收来自客户端的主动连接，至于 port 20 端口则为 FTP 服务器端主动连接至客户端。



![](http://cn.linux.vbird.org/linux_server/0410vsftpd_files/connect_active_nat.gif)



上述情况下，由于客户端是在防火墙后边，所以主动连接会有问题。此时，可以使用被动连接。客户端选择被动式（Passive）连接模式

主动式：服务器向客户端连接

被动式：客户端向服务器端发起连接。既然是由客户端发起连接，不需要考虑来自 port 20 的连接了。



### 被动式连接模式

![](http://cn.linux.vbird.org/linux_server/0410vsftpd_files/connect_passive.gif)



* 用户与服务器建立命令通道，经过三次握手

* 客户端发起 PASV 的连接要求

  当使用数据通道的命令时，客户端可通过命令通道发出 PASV 的被动式连接要求，并等待服务器的回应

* FTP服务器启动数据端口，并通知客户端连接

  FTP服务器启动一个监听端口。这个端口号码是随机的，然后会通过命令通道告知客户端此端口，并等待客户端的连接

* 客户端随机取用大于 1024 的端口进行连接

  客户端会随机取一个大于1024的端口来进行对主机的 port PASV 连接。此时，FTP数据就可以通过 port BB 及 port PASV 来传送了



**被动式 FTP 数据通道的连接方向是由客户端向服务器端连接的。 **客户端 => 服务器端



### FTP不同身份登陆

1. 开放实体用户的情况 real user

   以实体用户作为 FTP 登陆者身份时，系统默认并没有针对实体用户来进行限制，所以他可以针对整个文件系统进行任何他所具有权限的工作。所以建议如下

   * 使用替代的 FTP 方案：实体用户可以通过网络连接进行工作（SSH），因此没必要特别开放 FTP 服务，比如 sftp 本来就能达到传输文件的功能。
   * 限制用户能力，如 chroot 与 /sbin/nologin 等。如果确定要让实体用户利用 FTP 服务器的话，需要让某些系统账号无法登陆 FTP 才行，例如 bin、apache 等。可以通过 PAM 模块进行处理，例如 vsftpd 这个软件可以通过 `/etc/vsftpd/ftpusers` 这个文件来设置不想让它具有登陆权限 FTP 的账号。将用户身份设置成 chroot

2. 访客身份（Guest）

   服务器提供了个人Web网页的功能给一般身份用户，这些用户需要管理自己的网页空间

   * 仅提供需要登陆的账号即可，不需要提供系统上面所有人均可登陆的环境
   * 在服务器的设置当中，不同的访客具有不同的主目录，与用户的权限设置相符合。
   * 设置较多的限制：上传（下载）文件数目与硬盘容量的限制、连接登陆的时间限制、许可登陆的命令限制，且不允许 chmod 等

3. 匿名登陆用户（anonymous）

   共享一些软件资源，加一些限制。允许的命令要最小化，不许匿名用户使用命令；限制文件传输的数量，尽量不允许上传数据；限制匿名用户同时登陆的最大连接数量。



## vsftpd 服务器基础设置

vsftpd 支持 PID 的权限，还支持 chroot 这个函数的功能，chroot 就是 “change root directory” 的意思。root 指的是根目录而非系统管理员，它可以将某个特定的目录变成根目录。



### 软件以及配置文件

* /etc/vsftpd/vsftpd.conf

  主配置文件。文件的设置以 bash 的变量设置相同的方式来处理，就是 参数=设定值。等号两边不能有空格

* /etc/pam.d/vsftpd

  这是 vsftpd 使用 PAM 模块时的相关配置文件。主要用于作为身份认证之用，还有阻挡一些用户身份的功能

* /etc/vsftpd/ftpusers

  与上一个文件关联，也就是 PAM模块(/etc/pam.d/vsftpd)所指定的那个无法登陆的用户配置文件。把不想要登陆的 FTP 账号写入这个文件即可。一行一个账号。绝大部分的系统账号都在这个文件中，系统账号默认是没有办法使用 vsftpd 的

  ```bash
  # Users that are not allowed to login via ftp
  root
  bin
  daemon
  adm
  # ...省略
  ```

* /etc/vsftpd/user_list

  依赖 vsftpd.conf 的 userlist_enable 和 userlist_deny 这两个参数。userlist_deny={YES/NO}

  /etc/vsftpd/ftpusers 是 PAM 模块的阻挡访问设置项目，/etc/vsftpd/user_list 则是 vsftpd 自定义的阻挡访问项目。

  这个文件内容和 /etc/vsftpd/ftpusers 一模一样。默认情况下，将不允许登陆 vsftpd 的账号写入这里。

* /etc/vsftpd/chroot_list

  默认不存在，需要手动建立。主要功能：将某些账号的用户 chroot 建立在他们的默认用户主目录下。

  生效依赖与 vsftpd.conf 里的 chroot_list_enable、chroot_list_file 两个参数。

  如果想限制某些实体用户只在他们的用户主目录下而不许到其他目录，可以启用这个设置

* /usr/sbin/vsftpd

  vsftpd 的主要执行文件，只有这一个执行文件。

* /var/ftp/

  这是 vsftpd 默认匿名用户登陆的根目录，与 ftp 这个账号的家目录有关。

  ```bash
  # 就是家目录
  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
  ```

  

### vsftpd.conf 配置值

#### 1.与服务器环境有关的设置

* connect_from_port_20=YES(NO)

  主动式连接 FTP 服务器的 port端口。ftp-data 的端口号

* listen_port=21

  vsftpd 使用的命令通道 port，可以更改非正规端口号。

* dirmessage_enable=YES (NO)
  当用户进入某个目录时，会显示该目录需要注意的内容，显示的档案默认是 .message ，你可以使用底下的设定项目来修订！

* message_file=.message
  当 dirmessage_enable=YES 时，可以设定这个项目来让 vsftpd 寻找该档案来显示讯息！

* **listen=YES (NO)**
  若设定为 YES 表示 vsftpd 是以 standalone 的方式来启动的！预设是 NO 呦！所以我们的 CentOS 将它改为 YES 哩！这样才能使用 stand alone 的方式来唤醒。

* pasv_enable=YES (NO)
  支持数据流的被动式联机模式(passive mode)，一定要设定为 YES 的啦！

* **use_localtime=YES (NO)**
  是否使用本地时间？vsftpd 预设使用 GMT 时间(格林威治)，所以预设的 FTP 内的档案日期会比台湾晚 8 小时，建议修改设定为 YES 吧！

* **write_enable=YES (NO)**
  如果你允许用户上传数据时，就要启动这个设定值；

* connect_timeout=60
  单位是秒，在数据连接的主动式联机模式下，我们发出的连接讯号在 60 秒内得不到客户端的响应，则不等待并强制断线咯。 

* accept_timeout=60
  当用户以被动式 PASV 来进行数据传输时，如果服务器启用 passive port 并等待 client 超过 60 秒而无回应， 那么就给他强制断线！这个设定值与 connect_timeout 类似，不过一个是管理主动联机，一个管理被动联机。

* data_connection_timeout=300
  如果服务器与客户端的数据联机已经成功建立 (不论主动还是被动联机)，但是可能由于线路问题导致 300 秒内还是无法顺利的完成数据的传送，那客户端的联机就会被我们的 vsftpd 强制剔除！

* idle_session_timeout=300
  如果使用者在 300 秒内都没有命令动作，强制脱机！避免占用空间。

* max_clients=0
  如果 vsftpd 是以 stand alone 方式启动的，那么这个设定项目可以设定同一时间，最多有多少 client 可以同时连上 vsftpd 哩！限制使用 FTP 的用量！

* max_per_ip=0
  与上面 max_clients 类似，这里是同一个 IP 同一时间可允许多少联机？

* pasv_min_port=0, pasv_max_port=0
  上面两个是与 passive mode 使用的 port number 有关，如果你想要使用 65400 到 65410 这 11 个 port 来进行被动式联机模式的连接，可以这样设定 pasv_max_port=65410 以及 pasv_min_port=65400。 如果是 0 的话，表示随机取用而不限制。

* ftpd_banner=一些文字说明
  当使用者联机进入到 vsftpd 时，在 FTP 客户端软件上头会显示的说明文字。不过，这个设定值数据比较少啦！ 建议你可以使用底下的 banner_file 设定值来取代这个项目；

* **banner_file=/path/file**
  这个项目可以指定某个纯文本档作为使用者登入 vsftpd 服务器时所显示的欢迎字眼。同时，也能够放置一些让使用者知道本 FTP 服务器的目录架构！



#### 2.与实体用户相关的设置

- guest_enable=YES (NO)
  若这个值设定为 YES 时，那么任何实体账号，均会被假设成为 guest 喔 (所以预设是不开放的)！ 至于访客在 vsftpd 当中，预设会取得 ftp 这个使用者的相关权限。但可以透过 guest_username 来修改。
- guest_username=ftp
  在 guest_enable=YES 时才会生效，指定访客的身份而已。
- local_enable=YES (NO)
  这个设定值必须要为 YES 时，在 /etc/passwd 内的账号才能以实体用户的方式登入我们的 vsftpd 服务器喔！
- local_max_rate=0
  实体用户的传输速度限制，单位为 bytes/second， 0 为不限制。
- **chroot_local_user=YES (NO)**
  在预设的情况下，是否要将使用者限制在自己的家目录之内(chroot)？如果是 YES 代表用户默认就会被 chroot，如果是 NO， 则预设是没有 chroot。不过，实际还是需要底下的两个参数互相参考才行。为了安全性，这里应该要设定成 YES 才好。
- **chroot_list_enable=YES (NO)**
  是否启用 chroot 写入列表的功能？与底下的 chroot_list_flie 有关！这个项目得要开启，否则底下的列表档案会无效。 
- **chroot_list_file=/etc/vsftpd.chroot_list**
  如果 chroot_list_enable=YES 那么就可以设定这个项目了！这个项目与 chroot_local_user 有关
- userlist_enable=YES (NO)
  是否藉助 vsftpd 的抵挡机制来处理某些不受欢迎的账号，与底下的参数设定有关；
- userlist_deny=YES (NO)
  当 userlist_enable=YES 时才会生效的设定，若此设定值为 YES 时，则当使用者账号被列入到某个档案时， 在该档案内的使用者将无法登入 vsftpd 服务器！该档案文件名与下列设定项目有关。
- userlist_file=/etc/vsftpd/user_list
  若上面 userlist_deny=YES 时，则这个档案就有用处了！在这个档案内的账号都无法使用 vsftpd 喔！



#### 3.匿名用户登陆的设置

- anonymous_enable=YES (NO)
  设定为允许 anonymous 登入我们的 vsftpd 主机！预设是 YES ，底下的所有相关设定都需要将这个设定为 anonymous_enable=YES 之后才会生效！
- anon_world_readable_only=YES (NO)
  仅允许 anonymous 具有下载可读档案的权限，预设是 YES。
- anon_other_write_enable=YES (NO)
  是否允许 anonymous 具有除了写入之外的权限？包括删除与改写服务器上的档案及档名等权限。预设当然是 NO！如果要设定为 YES，那么开放给 anonymous 写入的目录亦需要调整权限，让 vsftpd 的 PID 拥有者可以写入才行！
- anon_mkdir_write_enable=YES (NO)
  是否让 anonymous 具有建立目录的权限？默认值是 NO！如果要设定为 YES， 那么 anony_other_write_enable 必须设定为 YES ！
- anon_upload_enable=YES (NO)
  是否让 anonymous 具有上传数据的功能，默认是 NO，如果要设定为 YES ，则 anon_other_write_enable=YES 必须设定。
- deny_email_enable=YES (NO)
  将某些特殊的 email address 抵挡住，不让那些 anonymous 登入！如果以 anonymous 登入服务器时，不是会要求输入密码吗？密码不是要你输入你的 email address 吗？如果你很讨厌某些 email address， 就可以使用这个设定来将他取消登入的权限！需与下个设定项目配合：
- banned_email_file=/etc/vsftpd/banned_emails
  如果 deny_email_enable=YES 时，可以利用这个设定项目来规定哪个 email address 不可登入我们的 vsftpd 喔！在上面设定的档案内，一行输入一个 email address 即可！
- no_anon_password=YES (NO)
  当设定为 YES 时，表示 anonymous 将会略过密码检验步骤，而直接进入 vsftpd 服务器内喔！所以一般预设都是 NO 的！(登入时会检查输入的 emai)
- anon_max_rate=0
  这个设定值后面接的数值单位为 bytes/秒 ，限制 anonymous 的传输速度，如果是 0 则不限制(由最大带宽所限制)，如果你想让 anonymous 仅有 30 KB/s 的速度，可以设定『anon_max_rate=30000』
- anon_umask=077
  限制 anonymous 上传档案的权限！如果是 077 则 anonymous 传送过来的档案权限会是 -rw------- 喔！



#### 4.关于系统安全方面的设置

- ascii_download_enable=YES (NO)
  如果设定为 YES ，那么 client 就优先 (预设) 使用 ASCII 格式下载文件。
- ascii_upload_enable=YES (NO)
  与上一个设定类似的，只是这个设定针对上传而言！预设是 NO
- one_process_model=YES (NO)
  这个设定项目比较危险一点～当设定为 YES 时，表示每个建立的联机都会拥有一支 process 在负责，可以增加 vsftpd 的效能。不过， 除非你的系统比较安全，而且硬件配备比较高，否则容易耗尽系统资源喔！一般建议设定为 NO 的啦！
- tcp_wrappers=YES (NO)
  当然我们都习惯支持 [TCP Wrappers](http://linux.vbird.org/linux_server/0250simple_firewall.php#tcp_wrappers) 的啦！所以设定为 YES 吧！
- xferlog_enable=YES (NO)
  当设定为 YES 时，使用者上传与下载文件都会被纪录起来。记录的档案与下一个设定项目有关：
- xferlog_file=/var/log/xferlog
  如果上一个 xferlog_enable=YES 的话，这里就可以设定了！这个是登录档的档名啦！
- xferlog_std_format=YES (NO)
  是否设定为 wu ftp 相同的登录档格式？预设为 NO ，因为登录档会比较容易读！ 不过，如果你有使用 wu ftp 登录文件的分析软件，这里才需要设定为 YES
- dual_log_enable=YES, vsftpd_log_file=/var/log/vsftpd.log
  除了 /var/log/xferlog 的 wu-ftp 格式登录档之外，还可以具有 vsftpd 的独特登录档格式喔！如果你的 FTP 服务器并不是很忙碌， 或许订出两个登录档的撰写 (/var/log/{vsftpd.log,xferlog) 是不错的。
- nopriv_user=nobody
  我们的 vsftpd 预设以 nobody 作为此一服务执行者的权限。因为 nobody 的权限相当的低，因此即使被入侵，入侵者仅能取得 nobody 的权限喔！
- pam_service_name=vsftpd
  这个是 pam 模块的名称，我们放置在 /etc/pam.d/vsftpd 即是这个咚咚！



### vsfptd 启动模式

利用 CentOS 提供的 script 来启动

```bash
/etc/init.d/vsftpd start
netstat -tunlp | grep 21
```



### CentOS 的 vsftpd 默认值

vsftpd 默认是同时开放实体用户与匿名用户的

```bash
> vim /etc/vsftpd/vsftpd.conf

# 1. 与匿名者有关的信息：
anonymous_enable=YES        <==支持匿名者的登入使用 FTP 功能

# 2. 与实体用户有关的设定
local_enable=YES            <==支持本地端的实体用户登入
write_enable=YES            <==允许用户上传数据 (包括档案与目录)
local_umask=022             <==建立新目录 (755) 与档案 (644) 的权限

# 3. 与服务器环境有关的设定
dirmessage_enable=YES       <==若目录下有 .message 则会显示该档案的内容
xferlog_enable=YES          <==启动登录文件记录，记录于 /var/log/xferlog
connect_from_port_20=YES    <==支持主动式联机功能
xferlog_std_format=YES      <==支持 WuFTP 的登录档格式
listen=YES                  <==使用 stand alone 方式启动 vsftpd
pam_service_name=vsftpd     <==支持 PAM 模块的管理
userlist_enable=YES         <==支持 /etc/vsftpd/user_list 档案内的账号登入管控！
tcp_wrappers=YES            <==支持 TCP Wrappers 的防火墙机制
```

- 你可以使用 anonymous 这个匿名账号或其他实体账号 (/etc/passwd) 登入；
- anonymous 的家目录在 /var/ftp ，且无上传权限，亦已经被 chroot 了；
- 实体用户的家目录参考 /etc/passwd，并没有被 chroot，可前往任何有权限可进入的目录中；
- 任何于 /etc/vsftpd/ftpusers 内存在的账号均无法使用 vsftpd (PAM)；
- 可利用 /etc/hosts.{allow|deny} 来作为基础防火墙；
- 当客户端有任何上传/下载信息时，该信息会被纪录到 /var/log/xferlog 中；
- 主动式联机的埠口为 port 20；



### 针对实体账号的设定

* 建立主配置文件 vsftpd.conf

  ```bash
  # 1. 与匿名者相关的信息，在这个案例中将匿名登录取消：
  anonymous_enable=NO
  
  # 2. 与实体用户相关的信息：可写入，且 umask 为 002 喔！
  local_enable=YES
  write_enable=YES
  local_umask=002
  userlist_enable=YES
  userlist_deny=YES
  userlist_file=/etc/vsftpd/user_list  <==这个档案必须存在！还好，预设有此档案！
  
  # 3. 与服务器环境有关的设定
  use_localtime=YES
  dirmessage_enable=YES
  xferlog_enable=YES
  connect_from_port_20=YES
  xferlog_std_format=YES
  listen=YES
  pam_service_name=vsftpd
  tcp_wrappers=YES
  banner_file=/etc/vsftpd/welcome.txt <==这个档案必须存在！需手动建立！
  ```

* 建立欢迎信息

  ```bash
  > vim /etc/vsftpd/welcome.txt
  欢迎光临本小站，本站提供 FTP 的相关服务！
  主要的服务是针对本机实体用户提供的，
  若有任何问题，请与鸟哥联络！
  ```

* 建立限制系统账号登陆的文件

  再来是针对系统账号来给予抵挡的机制，其实有两个档案啦，一个是 PAM 模块管的，一个是 vsftpd 主动提供的， 在预设的情况下这两个档案分别是：

  - /etc/vsftpd/ftpusers：就是 /etc/pam.d/vsftpd 这个档案的设定所影响的；
  - /etc/vsftpd/user_list：由 vsftpd.conf 的 userlist_file 所设定。

* 测试结果

  ```bash
  > ftp localhost
  ```



---



我们登录FTP有三种方式，匿名登录、本地用户登录和虚拟用户登录。

匿名登录：在登录FTP时使用默认的用户名，一般是ftp或anonymous。

本地用户登录：使用系统用户登录，在/etc/passwd中。

虚拟用户登录：guest 这是FTP专有用户，有两种方式实现虚拟用户，本地数据文件和数据库服务器。

FTP虚拟用户是FTP服务器的专有用户，使用虚拟用户登录FTP，只能访问FTP服务器提供的资源，大大增强了系统的安全。

https://blog.51cto.com/yuanbin/129071

https://blog.51cto.com/meiling/2071122. 推荐 👍





在系统中，没有权限登陆系统的用户一般也被称之为虚拟用户；虚拟用户也是要写进 /etc/passwd 中的，不一定。有的只是vsftpd的用户，两种方式

[虚拟用户]: https://blog.csdn.net/luoshao20120430/article/details/16900653



:question: yum 为何要安装 epel 扩展源 ？  https://www.cnblogs.com/cnjavahome/p/8463896.html

系统自带的yum源以及163的yum源还是无法安装一些工具，所有就想到了添加epel的强大yum源

[EPEL](https://www.vpser.net/manage/centos-rhel-linux-third-party-source-epel.html)（Extra Packages for Enterprise Linux）是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS等提供高质量软件包的项目。装上了 [EPEL](https://www.vpser.net/manage/centos-rhel-linux-third-party-source-epel.html)，就像在 Fedora 上一样，可以通过 yum install 软件包名，即可安装很多以前需要编译安装的软件、常用的软件或一些比较流行的软件，比如现在流行的nginx、htop、ncdu、vnstat等等，都可以使用EPEL很方便的安装更新。

目前可以直接通过执行命令： **yum install epel-release** 直接进行安装



pureftpd http://xiaohost.com/2423.html

https://www.cnblogs.com/cnjavahome/p/8463896.html



![ftp思维导图](http://s.i9u.cc/ftp%E6%9C%8D%E5%8A%A1%E5%99%A8.png)

