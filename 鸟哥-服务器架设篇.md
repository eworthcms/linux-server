> 鸟哥的Linux私房菜-服务器架设篇



# 第2章 网络基本概念

![第2章 网络的基础概念](/Users/smiler/笔记/linux/assets/第2章 网络的基础概念.png)

## 2.1 网络

### OSI 七层协议

> 将整个网络连接过程分成数个层次(layer),每个层次都有特定独立的功能,而且每个层次的程序代码可以独立编写,因为每个层次之间的功能并不会互相干扰.
>
> OSI 七层协议(Open System Interconnection)

![OSI七层协议](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_layer_to_layer.gif)



越接近硬件的阶层为底层(layer 1)，越接近应用程序的则是高层(layer 7).**不论是接收端还是发送端,每个层次只认识对方的同一层次的数据**

在七层协议中，每层都会有自己独特的头部数据(header)，告知对方这里边的信息是什么，而真正的数据就附在后头。

上层的包裹是放入下层的数据中，而数据前面则是这个数据的报头。

==第二层(数据链路层)比较特殊==,因为 **数据链路层** 位于软件包(packet)以及硬件数据帧(frame)中间的一个阶层，它必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个层次又分为两个子层来处理相对应的数据。

因为比较特殊，所以，第二层的数据格式比较不一样，尾端出现了一个检查码。

**物数网传输，会话表应用**



![物数网传输会话表应用](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_packet.gif)



| 分层              | 负责内容                                                     |
| ----------------- | ------------------------------------------------------------ |
| layer1 物理层     | 定义所使用的传输设备的电压与信号                             |
| layer2 数据链路层 | 偏软件部分：逻辑链路层控制，把上层数据包转成MAC格式<br />偏硬件部分：MAC数据帧，被物理层编码成比特流的数据 |
| layer3 网络层     | IP(Internet Protocol) 计算机之间 连接的建立、终止与维持  和 路由 route |
| layer4 传输层     | 发送端与接收端的连接技术(TCP、UDP) 数据包格式、数据包发送、传输是否送达并重发<br />**判断数据包是否可以正确的到达目标** 三次握手在TCP上 |
| layer5 会话层     | 网络管理、建立与断开、会话控制<br />**确定网络服务建立连接的确认** |
| layer6 表示层     | 本地端应用程序的数据格式转换为网络的标准格式<br />网络服务之间的数据格式的转换，包括 **数据的加解密** |
| layer7 应用层     | 定义应用程序如何进入该层的沟通接口，以及将数据接收或发送给应用程序 |



### TCP/IP 网络协议

**TCP/IP 通信协议**

TCP/IP 是在 OSI 七层协议的观念上，同样具有分层的架构，只是将它简化为四层。

![](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_tcpip.gif)



TCP/IP 将应用、表示、会话三层整合成一个应用层。

传输层没有变，不过依据 **传送的可靠性** 将封包格式分为 **面向连接的TCP** 和 **无连接的UDP**。

网络层没有变，主要内容是提供 IP 数据包，并可选择最佳路由来到达目标IP地址。

数据链路层与物理层则整合为一个网络接口层，包括定义硬件信号、数据帧转换为比特流的编码等，因此主要与硬件有关



---

:question: TCP/IP 如何工作？打开 Yahoo 网站

* 应用程序阶段：浏览器地址栏输入网址，回车。此时网址信息与相关数据被浏览器包成一个数据，向下传给 TCP/IP 的应用层。

* 应用层：由应用层提供 HTTP 通信协议，将来自浏览器的数据封装起来，并给予一个应用层报头，向传输层丢去
* 传输层：由于 HTTP 为可靠连接，因此数据进入 TCP 封装内，并给予一个 TCP 封包的报头，向网络层丢去
* 网络层：将 TCP 数据封装到 IP 数据包内，再给予一个 IP 包头(主要就是来源与目标的IP)，向网络接口层丢去
* 网络接口层：使用以太网络，IP 依据 CSMA/CD 的标准，封装到 MAC 数据帧中，并给予 MAC 帧头，再转成比特流后，利用传输介质发送到远程主机上



网络介质一次传输的数据量是有限的，因此如果被传输的数据太大时，我们在各层的封装中，就需要将数据先拆开放到不同的数据包中，再给数据包一个序号，好让目标端的主机能够利用这些序号再重新将数据整合回来。



> 接下来我们介绍的顺序是：TCP/IP的网络接口层、网络层、传输层来进行说明.
>
> TCP/IP中的应用层为`用户层`,底下的三层是我们谈及的`网络基础`



## 2.2 网络接口层

TCP/IP 最底层的 网络接口层 主要与硬件的关系比较密切。

广域网使用的设备：电话拨号、ADSL、电缆

局域网使用的设备：以太网



:question: 2M/128Kbps 为什么？

### 以太网络的传输协议：CSMA/CD

> 以太网的传输主要是 网卡对网卡的数据传递
>
> 每张以太网卡出厂时,会赋予一个独一无二的卡号，就是 MAC（Media Access Control）



![CSMA/CD连接](http://cn.linux.vbird.org/linux_server/0110network_basic_files/csmacd.gif)



集线器 是一种 **网络共享** 介质设备。网络共享介质在单一时间点内，仅能被一台主机所使用。

:point_right: 模拟 A发送到D 的流程

* 监听介质使用情况：A主机发送数据包前，先对网络介质进行监听,确定没人使用，再发送数据包
* 多点传输：A主机发送的数据会被集线器复制一份，然后发送给所有连接此集线器的主机。A发送出去的数据，B、C、D三部计算机都能够接收到，但由于目标是D主机，所以B与C会将数据帧丢掉，而D会抓下来处理
* 冲突检测：该数据帧有检测能力，若其他主机B在同时间内发送，则A与B的数据冲突，此时数据都被销毁，A与B各自随机等待一个时间，重新发送



交换器 Switch 是 **非共享的设备**，与集线器最大的差异，在于交换器内有一个特别的内存，整个内存可以记录每个 交换器port 与其连接的 PC 的 MAC 地址。

当来自 Switch 两端的PC要互传数据时，每个数据帧将直接通过交换器的内存数据而传送到目标主机上。



### MAC 的封装格式

上面提到的 CSMA/CD 发送出去的数据帧，其实就是 MAC。这个数据帧上有两个重要的数据，就是目标与来源的网卡卡号，因此简称网卡卡号为 MAC 地址。

MAC 是整个网络硬件上面传送数据的最小单位

Linux下可以使用 `ifconfig` 命令查看网卡卡号。

在这个 MAC 的传送中，仅在局域网络内生效，如果跨过不同的子网，那么来源与目的的硬件地址就会跟着改变了。因为变成不同网卡之间的交流了，所以卡号当然不同。



### 集线器、交换机与相关机制

交换器(Switch)与集线器(Hub)最大的差异:交换机内有一个特别的内存，这个内存可以记录每个 Switch port 与其连接的 PC 的 MAC 地址。所以 Switch 不是共享设备，每个数据帧都将通过交换器的内存数据而直接传送到目标主机上。

## 2.3 网络层

有网络就必须要有网络相关的硬件，最常见的网络硬件接口为 **以太网**，包括网线、网卡、Hub/Switch 等



### IP数据包的封装

![image-20190119225029579](/Users/smiler/笔记/linux/assets/image-20190119225029579.png)

IP有两个版本，一个是 IPV4，一种是 IPV6

IPV4 记录的地址仅有 32 位，预计2020年前后分配完毕。IPV6的地址可以达到 128 位，多出 2 的 96 次方



Time To Live（TTL 生存时间）

表示这个 IP 数据包的生存时间，范围为0～255 当这个IP数据包通过一个路由器时，TTL就减1，当TTL为0时，这个数据包将会直接丢弃。

:question: ttl 有什么用？

### IP地址的组成和分级

#### IP的组成

> IP是一种网络数据包，这个数据包的报头最重要的就是 那个32位的来源地址与目标地址

```bash
IP 的表示式：
00000000.00000000.00000000.00000000   ==> 0.0.0.0
11111111.11111111.11111111.11111111   ==> 255.255.255.255

#还可以分为两部分：Net_ID网络号码 与 Host_ID主机号码
192.168.0.0~192.168.0.255 这个 Class C 的说明：
11000000.10101000.00000000.00000000
11000000.10101000.00000000.11111111
|----------Net_ID---------|-host--|
```

前边的三组数字(192.168.0)就是网络号码，最后面一组数字为主机号码。

同一个网络：在同一个物理网段内，主机的IP具有相同的Net_ID，并且具有独特的Host_ID



在同一个网段内，Net_ID 是不变的，而  Host_ID 是不可重复的。

Host_ID全为0表示整个网段的地址(Network IP)，全为1表示广播的地址(Broadcast IP)   NB牛逼来记忆



#### IP的分级

将整个IP网段分为五种等级

```bash
以二进制说明 Network 第一个数字的定义：
Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 0
          |--net--|---------host------------|
Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 10
          |------net-------|------host------|
Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 110
          |-----------net-----------|-host--|
Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1110
Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1111

五种分级在十进制的表示：
Class A :   0.xx.xx.xx ~ 127.xx.xx.xx
Class B : 128.xx.xx.xx ~ 191.xx.xx.xx
Class C : 192.xx.xx.xx ~ 223.xx.xx.xx
Class D : 224.xx.xx.xx ~ 239.xx.xx.xx
Class E : 240.xx.xx.xx ~ 255.xx.xx.xx
```



### IP的种类

* Public IP：公共IP
* Private IP：私有IP或保留IP，不能直接联网，用于局域网络内的主机连接规划



私有IP网段

- Class A：10.0.0.0    - 10.255.255.255
- Class B：172.16.0.0  - 172.31.255.255
- Class C：192.168.0.0 - 192.168.255.255

**使用私有IP作为来源或目的地址的数据包，不能通过 Internet 来传送。通过 CSMA/CD 的功能在局域网进行广播，亦可以直接网卡对网卡传递数据(通过MAC数据帧)**



还有一个奇怪的 Class A的网络，为 lo 网络，被用来作为测试操作系统内部循环所用的一个网络，同时也能够提供给系统内部原本就需要使用网络接口的服务daemon所使用

127.0.0.0/8 这个 Class A，默认的主机(localhost)的IP是127.0.0.1



### Netmask、子网与CIDR

Class A 的网段有 256x256x(256-2) 这么多IP，回想 CSMA/CD，对所有计算机进行广播，会很卡顿。所以分成多个局域网，再来规划每个局域网内的计算机。总之，让 Class A 网段变小，将网络切的更细。

让 Class A 网段变小，将网络切的更细。

IP 有32位数值分为 网络号码与主机号码。以 Class C 为例，网络号占了 24 位，让第一个 Host_ID 当作 Net_ID，这样 Net_ID 就有 25 bits，Host_ID则为 7 bits。这样原来的 Class C 的网络被划分为**两个子局域网**，每个子局域网有 256/2-2 = 126 个可用IP



#### Netmask

或称为 Subnet mask 子网掩码。

这个IP网段可以分为 Net_ID 与 Host_ID ，既然 Net_ID 不可变，那就假设它占据的位已经用完（全部为1），而Host_ID是可变的，将它想成是保留值(全部为0),所以 Netmask 的表示为：

```php
192.168.0.0~192.168.0.255 这个 C Class 的 Netmask 说明
第一个 IP： 11000000.10101000.00000000.00000000
最后一个 ： 11000000.10101000.00000000.11111111
            |----------Net_ID---------|-host--|
Netmask  ： 11111111.11111111.11111111.00000000  <== Netmask 二进制
         ：   255   .  255   .  255   .   0      <== Netmask 十进制
特别注意喔，netmask 也是 32 位，在数值上，位于 Net_ID 的为 1 而 Host_ID 为 0
```

```php
Class A, B, C 三个等级的 Netmask 表示方式：
Class A : 11111111.00000000.00000000.00000000 ==> 255.  0.  0.  0
Class B : 11111111.11111111.00000000.00000000 ==> 255.255.  0.  0
Class C : 11111111.11111111.11111111.00000000 ==> 255.255.255.  0
```

```php
//192.168.0.1~192.168.0.255 这个 Class C 网络中,Netmask为255.255.255.0
Netmask:   255.255.255.0   <==网络定义中，最重要的参数
Network:   192.168.0.0     <==第一个 IP
Broadcast: 192.168.0.255   <==最后一个 IP
可用以设定成为主机的 IP 数：
192.168.0.1 ~ 192.168.0.254
```



#### 子网划分

Class C 可以继续分为子网(Subnet)的划分，如果 Net_ID 使用了25bits时

```php
原本的 C Class 的 Net_ID 与 Host_ID 的分别
11000000.10101000.00000000.00000000      Network:   192.168.0.0
11000000.10101000.00000000.11111111      Broadcast: 192.168.0.255
|----------Net_ID---------|-host--|

切成两个子网之后的 Net_ID 与 Host_ID 为何？
11000000.10101000.00000000.0 0000000  多了一个 Net_ID 了, 为 0 (第一个子网)
11000000.10101000.00000000.1 0000000  多了一个 Net_ID 了, 为 1 (第二个子网)
|----------Net_ID-----------|-host--|

第一个子网
Network:   11000000.10101000.00000000.0 0000000   192.168.0.0
Broadcast: 11000000.10101000.00000000.0 1111111   192.168.0.127
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128

第二个子网
Network:   11000000.10101000.00000000.1 0000000   192.168.0.128
Broadcast: 11000000.10101000.00000000.1 1111111   192.168.0.255
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128
```



---

192.168.0.0 ~ 192.168.0.255 这个网段，给予 Net_ID 是26位，分为几段？

26 - 24 = 2 用掉两个位，2的2次方，得到4个网段，再将256个IP平均分配到4个网段

```php
- 192.168.0.0~192.168.0.63            =>  192.168.0.0/26
- 192.168.0.64~192.168.0.127          =>  192.168.0.64/26
- 192.168.0.128~192.168.0.191         =>  192.168.0.128/26
- 192.168.0.192~192.168.0.255         =>  192.168.0.192/26

#用 >> 运算也可以 2>2=4    
```





#### 无类别域间路由 CIDR

> 将很多小网络合并为一个大网络。和netmask相反

```php
Network/Netmask
192.168.0.0/255.255.255.0
192.168.0.0/24    <==因为 Net_ID 共有 24 个 bits
```

**此处 `24` 为 Net_ID 的位数**

* classA  8
* classB  16
* classC  24



```php
// 将 Net_ID 借用来作为 Host_ID,可以将多个网络写成一个
192.168.0.0/16    //这样Class C变成了 Class B  打破原本IP等级的方式称为无类别域间路由 CIDR
```



[子网掩码计算器]: http://tool.chinaz.com/Tools/subnetmask





### 路由概念

同一个局域网里边，可以通过 IP 广播的方式实现数据传递。非局域网，需要使用路由器。



:question: 什么是同一个网络呢？

Network 以及 Netmask 来表示一个网络。同一网络的意思是 Network 相同，在同一个网段中。



两台客户机之间传递数据，通过 Net_ID 来知道是否在同一个网段内，每台主机都有自己的 “路由表”。



![路由表](http://cn.linux.vbird.org/linux_server/0110network_basic_files/route_1.jpg)



1) 查询IP数据包的目标IP地址

2) 查询是否位于本机所在的网络路由表中，如果是，直接通过局域网功能，将数据传送给目的地主机

3) 查询默认路由(Default Gateway)

4) 送出数据包至 Default Gateway 后，不理会数据包流向



每台主机里边都存在一个路由表，数据的传递将依据这个路由表进行传送。一旦数据包已经由路由表的路由条目发送出去后，那么主机本身就已经不再管数据包的流向了，因为该数据包的流向将是下一台主机进行传送。

​	

### 路由表

路由一旦设置错误，造成某些数据包无法正确的送出去。

每台主机都有自己的路由表，命令是 Route 

```bash
route [-n]
-n: 将主机名以 IP 的方式显示

> route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    0      0        0 eth0
link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0

> route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.21.0.1      0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0
```





## 2.4 传输层

网络层的 IP 数据包 只负责将数据送到正确的目标主机去，对于数据包到底会不会被接受，或者是有没有被正确接收，是传输层的任务之一。

> 面向连接的 TCP 数据包
>
> 无连接的 UDP 数据包



### 面向连接的可靠的 TCP 协议

TCP 数据包 包含以下

1) Source Port & Destination Port 源端口 & 目标端口

2) Sequence Number 数据包序号

​    当TCP数据太大时，需要分段。记录每个数据包的序号，让接收端按照序号重新组合

3) Acknowledge Number 回应序号

​    确认主机端确实收到了我们发送的数据包。当 Client 端收到这个确认码时，能确定传递的数据包被正确收下了

4) Data Offset 数据补偿

5) Reserved 保留

6) Code (Control Flag 控制标志码)

​    进行网络连接的时候，必须要说明这个连接的状态，好让接收端了解这个数据包的主要动作

​    URG

​    ACK(Acknowledge) 为1表示这个数据包为响应数据包，当 Client 端接收到这个确认码时，就能确定之前传递的数据包已经被正确收下了。

​    PSH

​    RST(Reset) 为1表示连接会被马上结束，无需等待终止确认手续。强制结束，发送端已断线

​    SYN(Synchronous) 为1表示发送端希望双方建立同步处理,也就是要求建立连接。SYN标志的数据包表示“主动”要连接对方的意思。

​    FIN(Finish) 为1表示传送结束，通知对方数据传毕，是否同意断线，只是发送者还在等待对方的响应而已。

7) Window (滑动窗口)

8) Checksum (确认校验码) 检测发送端的数据是否完整

9) Urgent Point (紧急数据)

10) Options (任意数据)

11) Padding (补足字段)



TCP 报头数据中，最重要的是 来源与目标的端口。

Linux 环境下，各网络服务与 port number 的对应默认写在 `/etc/services` 文件内

小于1024以下的端口要启动时，启动者的身份必须是 root 才行，所以叫特权端口。



### TCP 的三次握手

TCP 称为 可靠的数据传输协议，最重要的就是三次握手。



![三次握手](http://cn.linux.vbird.org/linux_server/0110network_basic_files/3_hand_shak.png)







A：数据包发起

客户端发起一个要求连接的数据包，在TCP的报头重，带有 SYN 的主动连接(SYN=1)，记录下数据包的序号(Sequence number = 10001)



B：数据包接收与确认数据包传送

当服务器接到这个数据包，并且确定要接收这个数据包后，制作一个同时带有 SYN=1,ACK=1 的数据包

其中 Acknowledge 的号码是给 Client 端确认用的，所以比 A步骤里的 Sequence 号码多一号(ack = 10001 + 1 = 10002)，我们的服务器也必须要确认客户端确实可以接收我们的数据包才行，所以也会发送一个 Sequence(seq = 20001) 给客户端，并且开始等待客户端给我们服务器端的回应。



C：回送确认数据包

当客户端收到来自服务器端的 ACK 数字后(10002)，就能够确认之前那个要求数据包被正确接收了，接下来如果客户端也同意与服务器端建立连接时，就会再次发送一个确认数据包(ACK=1)给服务器，即 Acknowledge = 20001 + 1 = 20002



D：取得最后确认

若一切顺利，在服务器端接收到带有 ACK=1 且 ack=20002 序号的数据包后，就能够建立起这次的连接了。



---

A：在不在？

B：在呢，你在不在

A：我也在

---



### 无连接的 UDP 协议

UDP 的全称是 User Datagram Protocol 用户数据报协议

UDP 不提供可靠的传送模式，因为它不是面向连接的机制，在 UDP 的传送过程中，接收端在接收到数据包之后，不会回复响应数据包(ACK)给发送端。

UDP 不需要确认对方是否正确的收到数据，可以比 TCP 更快速，通常用在 实时传送软件上，对数据的完整性没有精确需求的场景上。

**UDP 通信协议由于不需要连接确认，因此适用于快速实时传输且不需要数据可靠的软件中，例如实时通信。**



### 网络防火墙与OSI七层协议

利用防火墙机制与软件来进行数据包报头的分析，并且设定分析的规则，当发现某些特定的IP、特定的端口或者是特定的数据包信息(SYN/ACK等)，就将数据包丢弃，这就是基本的防火墙原理



第二层(数据链路层)：针对来源于目标的 MAC 进行阻挡

第三层(网络层)：针对来源于目标的 IP，以及 ICMP 的类别(type) 进行阻挡

第四层(传输层)：针对 TCP/UDP 的端口进行阻挡，也可以针对 TCP 的状态 (code) 来处理





# 第3章 局域网架构简介

局域网布线规划

网络设备选购建议



# 第4章 连接 Internet

```bash
#配置ip
> ifconfig eth0 192.168.1.100
> ifconfig
```



## 4.1 网络相关配置文件

| 所需网络参数                    | 主要配置文件档名                          | 重要参数                                                     |
| ------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| IP Netmask DHCP 与否 Gateway 等 | /etc/sysconfig/network-scripts/ifcfg-eth0 | DEVICE=网卡的名称 <br />BOOTPROTO=是否使用 dhcp <br />HWADDR=是否加入网卡(MAC) <br />IPADDR=就是IP地址 <br />NETMASK=子网掩码 <br />ONBOOT=要不要默认启动此接口 <br />GATEWAY=网关地址 <br />NM_CONTROLLED=额外的网管软件 <br />鸟哥建议取消这个项目！ |
| 主机名                          | /etc/sysconfig/network                    | NETWORKING=要不要有网络 <br />NETWORKING_IPV6=支持IPv6否<br /> HOSTNAME=你的主机名 |
| DNS IP                          | /etc/resolv.conf                          | nameserver DNS的IP                                           |
| 私有 IP 对应 的主机名           | /etc/hosts                                | 私有IP 主机名 别名                                           |

 

还有如下文件

* /etc/services

  记录 TCP/IP 上的各种协议，包括 HTTP、FTP、SSH、Telnet 等服务定义的 port number，都是这个文件规划出来的

* /etc/protocols

  定义 IP 数据包协议的相关数据，包括 ICMP/TCP/UDP 的数据包协议的定义等



网络方面的启动命令如下

```bash
#重新启动整个网络的参数。会主动去读取所有的网络配置文件
/etc/init.d/network restart

#启动或关闭某个网络接口,会去 /etc/sysconfig/network-scripts/ 目录下,读取适当的配置文件来处理
ifup eth0 (ifdown eth0)
```



## 4.2 连接 Internet 设置方法

### 4.2.1 手动配置固定IP参数

| 修改的参数 | 配置文件与重要启动脚本                                       | 观察结果的指令                                        |
| ---------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| IP相关参数 | /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/init.d/network restart | ifconfig (IP/Netmask) <br />route -n (gateway)        |
| DNS        | /etc/resolv.conf                                             | dig www.google.com                                    |
| 主机名     | /etc/sysconfig/network <br />/etc/hosts                      | hostname (主机名) <br />ping $(hostname) <br />reboot |

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE="eth0"               <==网卡名称，必须要 ifcfg-eth0 相对应
HWADDR="08:00:27:71:85:BD"  <==就是MAC地址，若只有一张网卡，可省略此项目
NM_CONTROLLED="no"          <==不要受到其他软件的网络管理！
ONBOOT="yes"                <==是否默认启动此接口的意思
BOOTPROTO=none              <==取得IP的方式，其实关键词只有dhcp，手动可输入none
IPADDR=192.168.1.100        <==就是 IP 啊
NETMASK=255.255.255.0       <==就是子网掩码
GATEWAY=192.168.1.254       <==就是默认路由
# 重点是上面这几个设定项目，底下的则可以省略的啰！
NETWORK=192.168.1.0         <==就是该网段的第一个 IP，可省略
BROADCAST=192.168.1.255     <==就是广播地址啰，可省略
MTU=1500                    <==就是最大传输单元的设定值，若不更改则可省略
```



配置完成后，我们重新启动网络接口，才能更新整个网络参数

```bash
/etc/init.d/network restart

#检查配置
#1.查看IP参数是否正确,重点是IP与Netmask
ifconfig eth0

#2.检查一下路由定义是否正确
route -n

#3.测试看看与路由器之间是否能够连接成功
ping -c 3 192.168.1.254
```



> DNS服务器IP的定义与查看

/etc/resolv.conf 会影响到是否可以查询到主机名称与IP的映射

```bash
vim /etc/resolv.conf
nameserver 168.95.1.1
nameserver 139.175.10.20

#4.检测定义的DNS服务器是否提供域名解析
dig www.baidu.com
```



> 主机名的修改、启动与查看

修改主机名需要修改 `/etc/sysconfig/network` 和 `/etc/hosts` 这两个文件

```bash
vim /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=www.centos.vbird

[root@www ~]# vim /etc/hosts
192.168.1.100    www.centos.vbird
# 特别注意，这个档案的原本内容不要删除！只要新增额外的数据即可！

> hostname

#5.检测主机名有没有对应的IP
ping -c 2 www.centos.vbird
```

**当修改过 /etc/sysconfig/network 里面的 HOSTNAME 后，必须重新启动 (reboot)**



### 4.2.2 自动取得IP参数

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
HWADDR="08:00:27:71:85:BD"
NM_CONTROLLED="no"
ONBOOT=yes
BOOTPROTO=dhcp
```

```bash
#重启
/etc/init.d/network restart
```

基本上，/etc/resolv.conf 默认会被 DHCP 所修改过，因此你不需要修改 /etc/resolv.conf。甚至连主机名都会被 DHCP 所修订。不过，如果你有特殊需求，那么 /etc/sysconfig/network 以及 /etc/hosts 请自行修改正确呦



检测配置的5个步骤

```bash
ifconfig
route -n
ping GW 的 IP
dig www.baidu.com
hostname
```



当我们需要主机名与IP的对应时，系统后先到 `etc/hosts` 文件查询对应的设置值，如果找不到，才会使用 `/etc/resolv.conf` 的设置去因特网查询



---

IP 参数设置在 `/etc/sysconfig/network-scripts/ifcfg-eth0` 中

主机名 设置在 `/etc/sysconfig/network` 中

DNS 设置在 `/etc/resolv.conf` 中

主机名与IP的对应 设置在 `/etc/hosts` 中



# 第5章 Linux常用的网络命令

## 5.1 设置网络参数的命令

ifconfig  查询、设置网卡与IP网络等相关参数

ifup ifdown  这是两个script文件,其作用是通过更简单的方式启动和关闭网络接口

route  查看、配置路由表(route table)

ip  整合式的命令，可以直接修改上述提到的功能



### ifconfig/ifup/ifdown

```bash
#可以手动启动、查看与修改网络接口的相关参数
ifconfig

#查看所有的网络接口
#直接输入 ifconfig 会列出当前已经被启动的网卡
ifconfig

#显示eth0这块网卡的相关数据，不管该网卡是否启动
ifconfig eth0

ifconfig eth0 192.168.100.100

> ifconfig eth0 192.168.100.100 \
netmask 255.255.255.128 mtu 8000

#将手动的处理全部取消 使用原有的设置值重置网络参数
/etc/init.d/network restart
```



使用 ifconfig 可以暂时手动来设置或修改某个适配卡的相关配置，然后可以使用 /etc/init.d/network restart 来重新启动整个网络接口，那么之前手动设置的数据就会全部失效。

要启动某个网络接口，又不让它具有IP参数时，直接使用 ifconfig eth0 up 即可



---



实时手动修改网络接口参数，可以利用 ifconfig 来实现。如果要直接以配置文件，就是 `/etc/sysconfig/network-scripts` 里边的 ifcfg-ethx 等文件的设置参数来启动网络接口的话，需要 ifup 或 ifdown 来完成



```bash
ifup eth0
ifdown eth0
```



ifup 与 ifdown 其实是 script ，它会直接到 /etc/sysconfig/network-scripts 目录下查找对应的配置文件。例如 ifup eth0 ,它会读取 ifcfg-eth0 整个文件的内容，加以设置。



### 修改路由 route

```bash
#单纯查看路由
route -n

route
```



route 与 route -n 的区别是 -n 参数会显示出 IP，至于只使用 route 命令，显示的则是 “主机名”。默认情况下，route 会解析出该 IP 的主机名。



### 网络参数综合命令 ip

综合了 ifconfig 与 route 这两个命令。

```bash
ip [option] [动作] [命令]
选项与参数
-s            显示出设备的统计数据
link          与设备device相关的设置 包括MTU、MAC地址等
addr/address  关于额外的IP协议,例如多IP的实现等
route         与路由有关的相关设置
```



```bash
#ip link 第二层数据链路层
ip link show
ip link set eth0 up

#ip address 第三层网络层
ip address show
ip addr

#ip route功能几乎与route差不多
ip route show
```



## 5.2 网络排错与查看命令

### 两台主机的两点沟通：ping

ping 是个很重要的命令，ping 主要通过 ICMP 数据包来进行整个网络的状态报告

```bash
ping [参数] IP
-c              执行 ping 的次数 -c 5
-n              输出数据时不进行 IP 与 主机名的反查,直接使用IP输出(更快)
-W              等待响应对方主机的秒数

选项与参数：
-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；
-n     ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；
-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；
-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；
-W 数值：等待响应对方主机的秒数。
-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：
   do  ：代表传送一个 DF (Don't Fragment) 旗标，让封包不能重新拆包与打包；
   dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包
```



### 两主机间各节点分析：traceroute

> ping 是两台主机之间的连通性判断
>
> traceroute 是两台主机之间各个节点(node)的通信状况



```bash
traceroute [选项与参数] IP
选项与参数：
-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！
-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；
-I ：使用 ICMP 的方式来进行侦测；
-T ：使用 TCP 来进行侦测，一般使用 port 80 测试
-w ：若对方主机在几秒钟内没有回声就声明不通...预设是 5 秒
-p 端口号：若不想使用 UDP 与 TCP 的预设端口号来侦测，可在此改变端口号。
-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；
         举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个 ppp，
         你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！
-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。

traceroute -n tw.yahoo.com
```



### 查看本机的网络连接与后门 netstat

```bash
netstat -[rn]       <==与路由有关的参数
netstat -[antulpc]  <==与网络接口有关的参数
选项与参数：
与路由 (route) 有关的参数说明：
-r  ：列出路由表(route table)，功能如同 route 这个指令；
-n  ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n
与网络接口有关的参数：
-a  ：列出所有的联机状态，包括 tcp/udp/unix socket 等；
-t  ：仅列出 TCP 封包的联机；
-u  ：仅列出 UDP 封包的联机；
-l  ：仅列出有在 Listen (监听) 的服务之网络状态；
-p  ：列出 PID 与 Program 的檔名；
-c  ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
```

```bash
#列出目前的路由表状态，且以 IP 及 port number 显示  
#route -n 一模一样
netstat -rn

#列出目前的所有网络联机状态，使用 IP 与 port number
netstat -an

#显示目前已经启动的网络服务
netstat -tunlp
```



服务名称与port number的对应关系在哪个文件？

/etc/services



### 检测主机名与IP的对应 host nslookup

#### host

这个指令可以查出某个主机名的IP

```bash
host [-a] hostname [server]
选项与参数：
-a ：列出该主机详细的各项主机名设定数据
[server] ：可以使用非为 /etc/resolv.conf 的 DNS 服务器 IP 来查询

host www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 220.181.112.244
```



#### nslookup

用途与host基本一样

```bash
nslookup [-query=[type]] [hostname|IP]
选项与参数：
-query=type：查询的类型，除了传统的 IP 与主机名对应外，DNS 还有很多信息，
             所以我们可以查询很多不同的信息，包括 mx, cname 等等，
             例如： -query=mx 的查询方法！

#找出 www.google.com 的IP
nslookup www.baidu.com
Server:		192.168.1.1
Address:	192.168.1.1#53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com.
Name:	www.a.shifen.com
Address: 220.181.112.244
```



## 5.3 远程连接命令与即时通信软件

### telnet

> 可以用来检测某个网站的端口是否开放
>
> telnet www.baidu.com 80

```bash
telnet [host|IP [port]]

#连接bbs站点
yum install telnet
telnet ptt.cc

#telnet 还可以用来连接到某个port(服务)上
#telnet 连接到 port 110,来查看整个port是否正确启动
telnet localhost 110

telnet localhost 25
```



## 5.4 文字接口网页浏览

### links

```bash
links [options] [URL]
选项与参数：
-anonymous [0|1]：是否使用匿名登录的意思；
-dump [0|1]     ：是否将网页的数据直接输出到 standard out 而非 links 软件功能
-dump_charset   ：后面接想要透过 dump 输出到屏幕的语系编码，big5 使用 cp950 喔

links http://www.baidu.com
```



因为你的环境可能是在 Linux 本机的 **tty1~tty6** ，所以无法显示出中文，这个时候你就得要设定为： 『LANG=en_US』之类的语系设定才行



### wget 文字接口下载器

> links 是进行网页的浏览
>
> wget 是进行网页数据的下载。wget是使用浏览器进行下载

```bash
wget [option] [网址]
选项与参数：
若想要联机的网站有提供账号与密码的保护时，可以利用这两个参数来输入喔！
--http-user=usrname
--http-password=password
--quiet ：不要显示 wget 在抓取数据时候的显示讯息
更多的参数请自行参考 man wget 吧！ ^_^

#代理proxy需要修改 /etc/wgetrc 来设置

wget http://www.baidu.com
```



### nc

nc 命令可以用来作为某些服务的检测，因为它可以连接到某个port来进行通信，此外，还可以自行启动一个port来监听其他用户的连接。

```bash
nc [-u] [IP|host] [port]
[root@www ~]# nc -l [IP|host] [port]
选项与参数：
-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；
-u ：不使用 TCP 而是使用 UDP 作为联机的封包状态

nc localhost 25
```











## 疑问

1M 上行和下行是多少？

126？



:question: tty1 和 tty6  









































