> **鸟哥的**Linux私房菜-服务器架设篇



# 第2章 网络基本概念

![第2章 网络的基础概念](http://s.i9u.cc/%E7%AC%AC2%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png)

## 2.1 网络

### OSI 七层协议

> 将整个网络连接过程分成数个层次(layer),每个层次都有特定独立的功能,而且每个层次的程序代码可以独立编写,因为每个层次之间的功能并不会互相干扰.
>
> OSI 七层协议(Open System Interconnection)

![OSI七层协议](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_layer_to_layer.gif)



越接近硬件的阶层为底层(layer 1)，越接近应用程序的则是高层(layer 7).**不论是接收端还是发送端,每个层次只认识对方的同一层次的数据**

在七层协议中，每层都会有自己独特的头部数据(header)，告知对方这里边的信息是什么，而真正的数据就附在后头。

上层的包裹是放入下层的数据中，而数据前面则是这个数据的报头。

==第二层(数据链路层)比较特殊==,因为 **数据链路层** 位于软件包(packet)以及硬件数据帧(frame)中间的一个阶层，它必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个层次又分为两个子层来处理相对应的数据。

因为比较特殊，所以，第二层的数据格式比较不一样，尾端出现了一个检查码。

**物数网传输，会话表应用**



![物数网传输会话表应用](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_packet.gif)



| 分层              | 负责内容                                                     |
| ----------------- | ------------------------------------------------------------ |
| layer1 物理层     | 定义所使用的传输设备的电压与信号                             |
| layer2 数据链路层 | 偏软件部分：逻辑链路层控制，把上层数据包转成MAC格式<br />偏硬件部分：MAC数据帧，被物理层编码成比特流的数据 |
| layer3 网络层     | IP(Internet Protocol) 计算机之间 连接的建立、终止与维持  和 路由 route |
| layer4 传输层     | 发送端与接收端的连接技术(TCP、UDP) 数据包格式、数据包发送、传输是否送达并重发<br />**判断数据包是否可以正确的到达目标** 三次握手在TCP上 |
| layer5 会话层     | 网络管理、建立与断开、会话控制<br />**确定网络服务建立连接的确认** |
| layer6 表示层     | 本地端应用程序的数据格式转换为网络的标准格式<br />网络服务之间的数据格式的转换，包括 **数据的加解密** |
| layer7 应用层     | 定义应用程序如何进入该层的沟通接口，以及将数据接收或发送给应用程序 |



### TCP/IP 网络协议

**TCP/IP 通信协议**

TCP/IP 是在 OSI 七层协议的观念上，同样具有分层的架构，只是将它简化为四层。

![](http://cn.linux.vbird.org/linux_server/0110network_basic_files/osi_tcpip.gif)



TCP/IP 将应用、表示、会话三层整合成一个应用层。

传输层没有变，不过依据 **传送的可靠性** 将封包格式分为 **面向连接的TCP** 和 **无连接的UDP**。

网络层没有变，主要内容是提供 IP 数据包，并可选择最佳路由来到达目标IP地址。

数据链路层与物理层则整合为一个网络接口层，包括定义硬件信号、数据帧转换为比特流的编码等，因此主要与硬件有关



---

:question: TCP/IP 如何工作？打开 Yahoo 网站

* 应用程序阶段：浏览器地址栏输入网址，回车。此时网址信息与相关数据被浏览器包成一个数据，向下传给 TCP/IP 的应用层。

* 应用层：由应用层提供 HTTP 通信协议，将来自浏览器的数据封装起来，并给予一个应用层报头，向传输层丢去
* 传输层：由于 HTTP 为可靠连接，因此数据进入 TCP 封装内，并给予一个 TCP 封包的报头，向网络层丢去
* 网络层：将 TCP 数据封装到 IP 数据包内，再给予一个 IP 包头(主要就是来源与目标的IP)，向网络接口层丢去
* 网络接口层：使用以太网络，IP 依据 CSMA/CD 的标准，封装到 MAC 数据帧中，并给予 MAC 帧头，再转成比特流后，利用传输介质发送到远程主机上



网络介质一次传输的数据量是有限的，因此如果被传输的数据太大时，我们在各层的封装中，就需要将数据先拆开放到不同的数据包中，再给数据包一个序号，好让目标端的主机能够利用这些序号再重新将数据整合回来。



> 接下来我们介绍的顺序是：TCP/IP的网络接口层、网络层、传输层来进行说明.
>
> TCP/IP中的应用层为`用户层`,底下的三层是我们谈及的`网络基础`



## 2.2 网络接口层

TCP/IP 最底层的 网络接口层 主要与硬件的关系比较密切。

广域网使用的设备：电话拨号、ADSL、电缆

局域网使用的设备：以太网



:question: 2M/128Kbps 为什么？

### 以太网络的传输协议：CSMA/CD

> 以太网的传输主要是 网卡对网卡的数据传递
>
> 每张以太网卡出厂时,会赋予一个独一无二的卡号，就是 MAC（Media Access Control）



![CSMA/CD连接](http://cn.linux.vbird.org/linux_server/0110network_basic_files/csmacd.gif)



集线器 是一种 **网络共享** 介质设备。网络共享介质在单一时间点内，仅能被一台主机所使用。

:point_right: 模拟 A发送到D 的流程

* 监听介质使用情况：A主机发送数据包前，先对网络介质进行监听,确定没人使用，再发送数据包
* 多点传输：A主机发送的数据会被集线器复制一份，然后发送给所有连接此集线器的主机。A发送出去的数据，B、C、D三部计算机都能够接收到，但由于目标是D主机，所以B与C会将数据帧丢掉，而D会抓下来处理
* 冲突检测：该数据帧有检测能力，若其他主机B在同时间内发送，则A与B的数据冲突，此时数据都被销毁，A与B各自随机等待一个时间，重新发送



交换器 Switch 是 **非共享的设备**，与集线器最大的差异，在于交换器内有一个特别的内存，整个内存可以记录每个 交换器port 与其连接的 PC 的 MAC 地址。

当来自 Switch 两端的PC要互传数据时，每个数据帧将直接通过交换器的内存数据而传送到目标主机上。



### MAC 的封装格式

上面提到的 CSMA/CD 发送出去的数据帧，其实就是 MAC。这个数据帧上有两个重要的数据，就是目标与来源的网卡卡号，因此简称网卡卡号为 MAC 地址。

MAC 是整个网络硬件上面传送数据的最小单位

Linux下可以使用 `ifconfig` 命令查看网卡卡号。

在这个 MAC 的传送中，仅在局域网络内生效，如果跨过不同的子网，那么来源与目的的硬件地址就会跟着改变了。因为变成不同网卡之间的交流了，所以卡号当然不同。



### 集线器、交换机与相关机制

交换器(Switch)与集线器(Hub)最大的差异:交换机内有一个特别的内存，这个内存可以记录每个 Switch port 与其连接的 PC 的 MAC 地址。所以 Switch 不是共享设备，每个数据帧都将通过交换器的内存数据而直接传送到目标主机上。

## 2.3 网络层

有网络就必须要有网络相关的硬件，最常见的网络硬件接口为 **以太网**，包括网线、网卡、Hub/Switch 等



### IP数据包的封装

![image-20190119225029579](http://markdown.icron.cc/image-20190119225029579.png)

IP有两个版本，一个是 IPV4，一种是 IPV6

IPV4 记录的地址仅有 32 位，预计2020年前后分配完毕。IPV6的地址可以达到 128 位，多出 2 的 96 次方



Time To Live（TTL 生存时间）

表示这个 IP 数据包的生存时间，范围为0～255 当这个IP数据包通过一个路由器时，TTL就减1，当TTL为0时，这个数据包将会直接丢弃。

:question: 网络解析的ttl 有什么用？

ttl 就是一条域名解析记录在DNS服务器中的存留时间。

TTL 就是 Time-to-live 的缩写，用来表明域名和IP对应关系在多长时间内有效，过了有效期就要重新去查询。

TTL 时间越长，缓存时间越长，更新越不容易及时生效。适合长度不更换，加快解析速度。

TTL 设置的小一些，生效时间就快一些，换空间的时候更合适。

[域名解析设置TTL多少合适?]: http://hizip.net/index.php/archives/20/



### IP地址的组成和分级

#### IP的组成

> IP是一种网络数据包，这个数据包的报头最重要的就是 那个32位的来源地址与目标地址

```bash
IP 的表示式：
00000000.00000000.00000000.00000000   ==> 0.0.0.0
11111111.11111111.11111111.11111111   ==> 255.255.255.255

#还可以分为两部分：Net_ID网络号码 与 Host_ID主机号码
192.168.0.0~192.168.0.255 这个 Class C 的说明：
11000000.10101000.00000000.00000000
11000000.10101000.00000000.11111111
|----------Net_ID---------|-host--|
```

前边的三组数字(192.168.0)就是网络号码，最后面一组数字为主机号码。

同一个网络：在同一个物理网段内，主机的IP具有相同的Net_ID，并且具有独特的Host_ID



在同一个网段内，Net_ID 是不变的，而  Host_ID 是不可重复的。

Host_ID全为0表示整个网段的地址(Network IP)，全为1表示广播的地址(Broadcast IP)   NB牛逼来记忆



#### IP的分级

将整个IP网段分为五种等级

```bash
以二进制说明 Network 第一个数字的定义：
Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 0
          |--net--|---------host------------|
Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 10
          |------net-------|------host------|
Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 110
          |-----------net-----------|-host--|
Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1110
Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1111

五种分级在十进制的表示：
Class A :   0.xx.xx.xx ~ 127.xx.xx.xx
Class B : 128.xx.xx.xx ~ 191.xx.xx.xx
Class C : 192.xx.xx.xx ~ 223.xx.xx.xx
Class D : 224.xx.xx.xx ~ 239.xx.xx.xx
Class E : 240.xx.xx.xx ~ 255.xx.xx.xx
```



### IP的种类

* Public IP：公共IP
* Private IP：私有IP或保留IP，不能直接联网，用于局域网络内的主机连接规划



私有IP网段

- Class A：10.0.0.0    - 10.255.255.255
- Class B：172.16.0.0  - 172.31.255.255
- Class C：192.168.0.0 - 192.168.255.255

**使用私有IP作为来源或目的地址的数据包，不能通过 Internet 来传送。通过 CSMA/CD 的功能在局域网进行广播，亦可以直接网卡对网卡传递数据(通过MAC数据帧)**



还有一个奇怪的 Class A的网络，为 lo 网络，被用来作为测试操作系统内部循环所用的一个网络，同时也能够提供给系统内部原本就需要使用网络接口的服务daemon所使用

127.0.0.0/8 这个 Class A，默认的主机(localhost)的IP是127.0.0.1



### Netmask、子网与CIDR

Class A 的网段有 256x256x(256-2) 这么多IP，回想 CSMA/CD，对所有计算机进行广播，会很卡顿。所以分成多个局域网，再来规划每个局域网内的计算机。总之，让 Class A 网段变小，将网络切的更细。

让 Class A 网段变小，将网络切的更细。

IP 有32位数值分为 网络号码与主机号码。以 Class C 为例，网络号占了 24 位，让第一个 Host_ID 当作 Net_ID，这样 Net_ID 就有 25 bits，Host_ID则为 7 bits。这样原来的 Class C 的网络被划分为**两个子局域网**，每个子局域网有 256/2-2 = 126 个可用IP



#### Netmask

或称为 Subnet mask 子网掩码。

这个IP网段可以分为 Net_ID 与 Host_ID ，既然 Net_ID 不可变，那就假设它占据的位已经用完（全部为1），而Host_ID是可变的，将它想成是保留值(全部为0),所以 Netmask 的表示为：

```php
192.168.0.0~192.168.0.255 这个 C Class 的 Netmask 说明
第一个 IP： 11000000.10101000.00000000.00000000
最后一个 ： 11000000.10101000.00000000.11111111
            |----------Net_ID---------|-host--|
Netmask  ： 11111111.11111111.11111111.00000000  <== Netmask 二进制
         ：   255   .  255   .  255   .   0      <== Netmask 十进制
特别注意喔，netmask 也是 32 位，在数值上，位于 Net_ID 的为 1 而 Host_ID 为 0
```

```php
Class A, B, C 三个等级的 Netmask 表示方式：
Class A : 11111111.00000000.00000000.00000000 ==> 255.  0.  0.  0
Class B : 11111111.11111111.00000000.00000000 ==> 255.255.  0.  0
Class C : 11111111.11111111.11111111.00000000 ==> 255.255.255.  0
```

```php
//192.168.0.1~192.168.0.255 这个 Class C 网络中,Netmask为255.255.255.0
Netmask:   255.255.255.0   <==网络定义中，最重要的参数
Network:   192.168.0.0     <==第一个 IP
Broadcast: 192.168.0.255   <==最后一个 IP
可用以设定成为主机的 IP 数：
192.168.0.1 ~ 192.168.0.254
```



#### 子网划分

Class C 可以继续分为子网(Subnet)的划分，如果 Net_ID 使用了25bits时

```php
原本的 C Class 的 Net_ID 与 Host_ID 的分别
11000000.10101000.00000000.00000000      Network:   192.168.0.0
11000000.10101000.00000000.11111111      Broadcast: 192.168.0.255
|----------Net_ID---------|-host--|

切成两个子网之后的 Net_ID 与 Host_ID 为何？
11000000.10101000.00000000.0 0000000  多了一个 Net_ID 了, 为 0 (第一个子网)
11000000.10101000.00000000.1 0000000  多了一个 Net_ID 了, 为 1 (第二个子网)
|----------Net_ID-----------|-host--|

第一个子网
Network:   11000000.10101000.00000000.0 0000000   192.168.0.0
Broadcast: 11000000.10101000.00000000.0 1111111   192.168.0.127
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128

第二个子网
Network:   11000000.10101000.00000000.1 0000000   192.168.0.128
Broadcast: 11000000.10101000.00000000.1 1111111   192.168.0.255
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128
```



---

192.168.0.0 ~ 192.168.0.255 这个网段，给予 Net_ID 是26位，分为几段？

26 - 24 = 2 用掉两个位，2的2次方，得到4个网段，再将256个IP平均分配到4个网段

```php
- 192.168.0.0~192.168.0.63            =>  192.168.0.0/26
- 192.168.0.64~192.168.0.127          =>  192.168.0.64/26
- 192.168.0.128~192.168.0.191         =>  192.168.0.128/26
- 192.168.0.192~192.168.0.255         =>  192.168.0.192/26

#用 >> 运算也可以 2>2=4    
```





#### 无类别域间路由 CIDR

> 将很多小网络合并为一个大网络。和netmask相反

```php
Network/Netmask
192.168.0.0/255.255.255.0
192.168.0.0/24    <==因为 Net_ID 共有 24 个 bits
```

**此处 `24` 为 Net_ID 的位数**

* classA  8
* classB  16
* classC  24



```php
// 将 Net_ID 借用来作为 Host_ID,可以将多个网络写成一个
192.168.0.0/16    //这样Class C变成了 Class B  打破原本IP等级的方式称为无类别域间路由 CIDR
```



[子网掩码计算器]: http://tool.chinaz.com/Tools/subnetmask





### 路由概念

同一个局域网里边，可以通过 IP 广播的方式实现数据传递。非局域网，需要使用路由器。



:question: 什么是同一个网络呢？

Network 以及 Netmask 来表示一个网络。同一网络的意思是 Network 相同，在同一个网段中。



两台客户机之间传递数据，通过 Net_ID 来知道是否在同一个网段内，每台主机都有自己的 “路由表”。



![路由表](http://cn.linux.vbird.org/linux_server/0110network_basic_files/route_1.jpg)



1) 查询IP数据包的目标IP地址

2) 查询是否位于本机所在的网络路由表中，如果是，直接通过局域网功能，将数据传送给目的地主机

3) 查询默认路由器(Default Gateway) 

4) 送出数据包至 Default Gateway 后，不理会数据包流向



每台主机里边都存在一个路由表，数据的传递将依据这个路由表进行传送。一旦数据包已经由路由表的路由条目发送出去后，那么主机本身就已经不再管数据包的流向了，因为该数据包的流向将是下一台主机来进行传送。

​	

**数据来了，先查自己的路由表。如果在同一个网络(Net_ID相同,Host_ID不同)里，IP广播的形式MAC to MAC进行传递。如果不在一个网络里，则直接发送给默认路由器(Default Gateway)**

### 路由表

路由一旦设置错误，造成某些数据包无法正确的送出去。

每台主机都有自己的路由表，命令是 Route 

```bash
route [-n]
-n: 将主机名以 IP 的方式显示

> route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    0      0        0 eth0
link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0

> route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.21.0.1      0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0
```

几乎每一台主机都会有一个 Default Gateway 来负责所有非局域网络内的数据包传递。



🐸 网络层主要是进行数据的传递。每台主机有自己的路由表，当数据传递过来时，查询路由表，看是不是在同一个局域网，如果目标IP在同一个局域网，则直接进行传递；如果不在同一个局域网，则把数据发送给路由表的 default gateway。可以通过 ping 和 traceroute 来检查网络的状态。

网络层的IP数据包只负责将数据传送到正确的目标主机去。

## 2.4 传输层

网络层的 IP 数据包 只负责将数据送到正确的目标主机去，对于数据包到底会不会被接受，或者是有没有被正确接收，是传输层的任务之一。

> 面向连接的 TCP 数据包
>
> 无连接的 UDP 数据包



### 面向连接的可靠的 TCP 协议

TCP 数据包 包含以下

1) Source Port & Destination Port 源端口 & 目标端口

2) Sequence Number 数据包序号

​    当TCP数据太大时，需要分段。记录每个数据包的序号，让接收端按照序号重新组合

3) Acknowledge Number 回应序号

​    确认主机端确实收到了我们发送的数据包。当 Client 端收到这个确认码时，能确定传递的数据包被正确收下了

4) Data Offset 数据补偿

5) Reserved 保留

6) Code (Control Flag 控制标志码)

​    进行网络连接的时候，必须要说明这个连接的状态，好让接收端了解这个数据包的主要动作

​    URG

​    ACK(Acknowledge) 为1表示这个数据包为响应数据包，当 Client 端接收到这个确认码时，就能确定之前传递的数据包已经被正确收下了。

​    PSH

​    RST(Reset) 为1表示连接会被马上结束，无需等待终止确认手续。强制结束，发送端已断线

​    SYN(Synchronous) 为1表示发送端希望双方建立同步处理,也就是要求建立连接。SYN标志的数据包表示“主动”要连接对方的意思。

​    FIN(Finish) 为1表示传送结束，通知对方数据传毕，是否同意断线，只是发送者还在等待对方的响应而已。

7) Window (滑动窗口)

8) Checksum (确认校验码) 检测发送端的数据是否完整

9) Urgent Point (紧急数据)

10) Options (任意数据)

11) Padding (补足字段)



TCP 报头数据中，最重要的是 来源与目标的端口。

Linux 环境下，各网络服务与 port number 的对应默认写在 `/etc/services` 文件内

小于1024以下的端口要启动时，启动者的身份必须是 root 才行，所以叫特权端口。



### TCP 的三次握手

TCP 称为 可靠的数据传输协议，最重要的就是三次握手。



![三次握手](http://cn.linux.vbird.org/linux_server/0110network_basic_files/3_hand_shak.png)







A：数据包发起

客户端发起一个要求连接的数据包，在TCP的报头重，带有 SYN 的主动连接(SYN=1)，记录下数据包的序号(Sequence number = 10001)



B：数据包接收与确认数据包传送

当服务器接到这个数据包，并且确定要接收这个数据包后，制作一个同时带有 SYN=1,ACK=1 的数据包

其中 Acknowledge 的号码是给 Client 端确认用的，所以比 A步骤里的 Sequence 号码多一号(ack = 10001 + 1 = 10002)，我们的服务器也必须要确认客户端确实可以接收我们的数据包才行，所以也会发送一个 Sequence(seq = 20001) 给客户端，并且开始等待客户端给我们服务器端的回应。



C：回送确认数据包

当客户端收到来自服务器端的 ACK 数字后(10002)，就能够确认之前那个要求数据包被正确接收了，接下来如果客户端也同意与服务器端建立连接时，就会再次发送一个确认数据包(ACK=1)给服务器，即 Acknowledge = 20001 + 1 = 20002



D：取得最后确认

若一切顺利，在服务器端接收到带有 ACK=1 且 ack=20002 序号的数据包后，就能够建立起这次的连接了。



---

A：在不在？

B：在呢，你在不在

A：我也在

---



### 无连接的 UDP 协议

UDP 的全称是 User Datagram Protocol 用户数据报协议

UDP 不提供可靠的传送模式，因为它不是面向连接的机制，在 UDP 的传送过程中，接收端在接收到数据包之后，不会回复响应数据包(ACK)给发送端。

UDP 不需要确认对方是否正确的收到数据，可以比 TCP 更快速，通常用在 实时传送软件上，对数据的完整性没有精确需求的场景上。

**UDP 通信协议由于不需要连接确认，因此适用于快速实时传输且不需要数据可靠的软件中，例如实时通信。**



### 网络防火墙与OSI七层协议

利用防火墙机制与软件来进行数据包报头的分析，并且设定分析的规则，当发现某些特定的IP、特定的端口或者是特定的数据包信息(SYN/ACK等)，就将数据包丢弃，这就是基本的防火墙原理



第二层(数据链路层)：针对来源于目标的 MAC 进行阻挡

第三层(网络层)：针对来源于目标的 IP，以及 ICMP 的类别(type) 进行阻挡

第四层(传输层)：针对 TCP/UDP 的端口进行阻挡，也可以针对 TCP 的状态 (code) 来处理



在 Linux 中，DNS 主机IP的设定在 /etc/resolv.conf

DNS 的主要目的 在于进行 Host Name 与对应的 IP 的解析功能。

# 第3章 局域网架构简介

局域网布线规划

网络设备选购建议



# 第4章 连接 Internet

```bash
#确认网卡被内核捕捉到
dmesg | grep -in eth

#查看网卡卡号
ifconfig eth0
```





```bash
#配置ip
> ifconfig eth0 192.168.1.100
> ifconfig

#ip设置好之后，利用ping指令来ping一下局域网内的其他计算机，如果有响应，则网卡配置好了
```



## 4.1 网络相关配置文件

| 所需网络参数                    | 主要配置文件档名                          | 重要参数                                                     |
| ------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| IP Netmask DHCP 与否 Gateway 等 | /etc/sysconfig/network-scripts/ifcfg-eth0 | DEVICE=网卡的名称 <br />BOOTPROTO=是否使用 dhcp <br />HWADDR=是否加入网卡(MAC) <br />IPADDR=就是IP地址 <br />NETMASK=子网掩码 <br />ONBOOT=要不要默认启动此接口 <br />GATEWAY=网关地址 <br />NM_CONTROLLED=额外的网管软件 <br />鸟哥建议取消这个项目！ |
| 主机名                          | /etc/sysconfig/network                    | NETWORKING=要不要有网络 <br />NETWORKING_IPV6=支持IPv6否<br /> HOSTNAME=你的主机名 |
| DNS IP                          | /etc/resolv.conf                          | nameserver DNS的IP                                           |
| 私有 IP 对应 的主机名           | /etc/hosts                                | 私有IP 主机名 别名                                           |

 

还有如下文件

* /etc/services

  记录 TCP/IP 上的各种协议，包括 HTTP、FTP、SSH、Telnet 等服务定义的 port number，都是这个文件规划出来的

* /etc/protocols

  定义 IP 数据包协议的相关数据，包括 ICMP/TCP/UDP 的数据包协议的定义等



网络方面的启动命令如下

```bash
#重新启动整个网络的参数。会主动去读取所有的网络配置文件
/etc/init.d/network restart

#启动或关闭某个网络接口,会去 /etc/sysconfig/network-scripts/ 目录下,读取适当的配置文件来处理
ifup eth0 (ifdown eth0)
```



## 4.2 连接 Internet 设置方法

### 4.2.1 手动配置固定IP参数

| 修改的参数 | 配置文件与重要启动脚本                                       | 观察结果的指令                                        |
| ---------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| IP相关参数 | /etc/sysconfig/network-scripts/ifcfg-eth0 <br />/etc/init.d/network restart | ifconfig (IP/Netmask) <br />route -n (gateway)        |
| DNS        | /etc/resolv.conf                                             | dig www.google.com                                    |
| 主机名     | /etc/sysconfig/network <br />/etc/hosts                      | hostname (主机名) <br />ping $(hostname) <br />reboot |

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE="eth0"               <==网卡名称，必须要 ifcfg-eth0 相对应
HWADDR="08:00:27:71:85:BD"  <==就是MAC地址，若只有一张网卡，可省略此项目
NM_CONTROLLED="no"          <==不要受到其他软件的网络管理！
ONBOOT="yes"                <==是否默认启动此接口的意思
BOOTPROTO=none              <==取得IP的方式，其实关键词只有dhcp，手动可输入none 重要
IPADDR=192.168.1.100        <==就是 IP 啊
NETMASK=255.255.255.0       <==就是子网掩码
GATEWAY=192.168.1.254       <==就是默认路由
# 重点是上面这几个设定项目，底下的则可以省略的啰！
NETWORK=192.168.1.0         <==就是该网段的第一个 IP，可省略
BROADCAST=192.168.1.255     <==就是广播地址啰，可省略
MTU=1500                    <==就是最大传输单元的设定值，若不更改则可省略
```



配置完成后，我们重新启动网络接口，才能更新整个网络参数

```bash
/etc/init.d/network restart

#检查配置
#1.查看IP参数是否正确,重点是IP与Netmask
ifconfig eth0

#2.检查一下路由定义是否正确
route -n
192.168.1.254

#3.测试看看与路由器之间是否能够连接成功
ping -c 3 192.168.1.254
```

这三步配置完之后，TCP/IP参数就配置完毕，可以使用 IP 上网了，不能够使用主机名上网，因为没有定义 DNS



> DNS服务器IP的定义与查看

/etc/resolv.conf 会影响到是否可以查询到主机名称与IP的映射

```bash
#DNS服务器地址
vim /etc/resolv.conf
nameserver 168.95.1.1
nameserver 139.175.10.20 

#4.检测定义的DNS服务器是否提供域名解析
dig www.baidu.com
```



> 主机名的修改、启动与查看

修改主机名需要修改 `/etc/sysconfig/network` 和 `/etc/hosts` 这两个文件

```bash
vim /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=www.centos.vbird

[root@www ~]# vim /etc/hosts
192.168.1.100    www.centos.vbird
# 特别注意，这个档案的原本内容不要删除！只要新增额外的数据即可！

> hostname  #查看是否修改成功了

#5.检测主机名有没有对应的IP
ping -c 2 www.centos.vbird
```

**当修改过 /etc/sysconfig/network 里面的 HOSTNAME 后，必须重新启动 (reboot)**



### 4.2.2 自动取得IP参数

```bash
vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
HWADDR="08:00:27:71:85:BD"
NM_CONTROLLED="no"
ONBOOT=yes
BOOTPROTO=dhcp
```

```bash
#重启
/etc/init.d/network restart
```

基本上，/etc/resolv.conf 默认会被 DHCP 所修改过，因此你不需要修改 /etc/resolv.conf。甚至连主机名都会被 DHCP 所修订。不过，如果你有特殊需求，那么 /etc/sysconfig/network 以及 /etc/hosts 请自行修改正确呦



检测配置的5个步骤

```bash
ifconfig
route -n
ping GW 的 IP  #ping路由的ip
dig www.baidu.com
hostname
```



当我们需要主机名与IP的对应时，系统后先到 `etc/hosts` 文件查询对应的设置值，如果找不到，才会使用 `/etc/resolv.conf` 的设置去因特网查询



---

IP 参数设置在 `/etc/sysconfig/network-scripts/ifcfg-eth0` 中

主机名 设置在 `/etc/sysconfig/network` 中

DNS 设置在 `/etc/resolv.conf` 中

主机名与IP的对应 设置在 `/etc/hosts` 中



# 第5章 Linux常用的网络命令

![常用的网络命令](http://s.i9u.cc/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4.png)

## 5.1 设置网络参数的命令

ifconfig  查询、设置网卡与IP网络等相关参数

ifup ifdown  这是两个script文件,其作用是通过更简单的方式启动和关闭网络接口

route  查看、配置路由表(route table)

ip  整合式的命令，可以直接修改上述提到的功能



### ifconfig

> ifup 与 ifdown 仅能根据 /etc/sysconfig/network-scripts 内的 ifcfg-ethX(X为数字)进行启动或关闭的操作，并不能直接修改网络参数，除非手动调整 ifcfg-ethX 文件才行。=> 可以针对指定的网卡进行关闭和开启
>
> ifconfig 则可以直接手动为某个接口配置 IP 或调整其网络参数

```bash
#可以手动启动、查看与修改网络接口的相关参数
ifconfig

#查看所有的网络接口
#直接输入 ifconfig 会列出当前已经被启动的网卡,不管这个网卡是否有被设置IP,都会被显示出来
ifconfig

#显示eth0这块网卡的相关数据，不管该网卡是否启动
ifconfig eth0

ifconfig eth0 192.168.100.100

> ifconfig eth0 192.168.100.100 \
netmask 255.255.255.128 mtu 8000

#eth0:0 在该实体网卡上,再仿真一个网络接口 在一张网卡上面设置多个IP的意思
> ifconfig eth0:0 192.168.50.50 

> ifconfig eth0:0 down

#将手动的处理全部取消 使用原有的设置值重置网络参数
/etc/init.d/network restart
```



使用 ifconfig 可以暂时手动来设置或修改某个适配卡的相关配置，然后可以使用 /etc/init.d/network restart 来重新启动整个网络接口，那么之前手动设置的数据就会全部失效。

要启动某个网络接口，又不让它具有IP参数时，直接使用 ifconfig eth0 up 即可



---



### ifup/ifdown

实时手动修改网络接口参数，可以利用 ifconfig 来实现。如果要直接以配置文件，就是 `/etc/sysconfig/network-scripts` 里边的 ifcfg-ethx 等文件的设置参数来启动网络接口的话，需要 ifup 或 ifdown 来完成



```bash
ifup eth0
ifdown eth0
```



ifup 与 ifdown 其实是 script ，它会直接到 /etc/sysconfig/network-scripts 目录下查找对应的配置文件。例如 ifup eth0 ,它会读取 ifcfg-eth0 整个文件的内容，加以设置。



### 修改路由 route

```bash
#单纯查看路由
route -n

route
```



route 与 route -n 的区别是 -n 参数会显示出 IP，至于只使用 route 命令，显示的则是 “主机名”。默认情况下，route 会解析出该 IP 的主机名。

路由是有顺序的，数据从小网络到大网络。

```bash
#腾讯服务器的路由
[root@VM_0_7_centos ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.21.0.1      0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.21.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0
```

解读一下：如果要传送到 baidu 的主机。百度的主机IP是 180.149.131.98 

1. 判断百度的主机IP在不在 172.21.0.0/20 范围里
2. 判断百度的主机IP在不在 169.254.0.0/16 范围里
3. 到达默认路由，通过eth0将数据包发送给 172.21.0.1 这台 Gateway 主机。所以说路由是有顺序的。



### 网络参数综合命令 ip

综合了 ifconfig 与 route 这两个命令。

```bash
ip [option] [动作] [命令]
选项与参数
-s            显示出设备的统计数据
link          与设备device相关的设置 包括MTU、MAC地址等
addr/address  关于额外的IP协议,例如多IP的实现等
route         与路由有关的相关设置
```



```bash
#ip link 第二层数据链路层
#显示本机所有接口的信息
ip link show
ip link set eth0 up
ip link set eth0 down

#ip address 第三层网络层
ip address show
ip addr
ip addr show eth0

#ip route功能几乎与route差不多
#显示当前的路由信息
ip route show
```



## 5.2 网络排错与查看命令

### 两台主机的两点沟通：ping

ping 是个很重要的命令，ping 主要通过 ICMP 数据包来进行整个网络的状态报告

```bash
ping [参数] IP
-c              执行 ping 的次数 -c 5
-n              输出数据时不进行 IP 与 主机名的反查,直接使用IP输出(更快)
-W              等待响应对方主机的秒数

选项与参数：
-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；
-n     ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；
-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；
-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；
-W 数值：等待响应对方主机的秒数。
-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：
   do  ：代表传送一个 DF (Don't Fragment) 旗标，让封包不能重新拆包与打包；
   dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包
   
ping -c 3 168.95.1.1   
```

ping 最简单的功能就是发送 ICMP 数据包去要求对方主机回应是否在网络环境中

### 两主机间各节点分析：traceroute

> ping 是两台主机之间的连通性判断
>
> traceroute 是两台主机之间各个节点(node)的通信状况



```bash
traceroute [选项与参数] IP
选项与参数：
-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！
-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；
-I ：使用 ICMP 的方式来进行侦测；
-T ：使用 TCP 来进行侦测，一般使用 port 80 测试
-w ：若对方主机在几秒钟内没有回声就声明不通...预设是 5 秒
-p 端口号：若不想使用 UDP 与 TCP 的预设端口号来侦测，可在此改变端口号。
-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；
         举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个 ppp，
         你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！
-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。

traceroute -n tw.yahoo.com  #UDP检测
traceroute -w 1 -n -T www.baidu.com
```



### 查看本机的网络连接与后门 netstat

某个网络服务明明已经启动了，但是就是无法进行连接，要先查询下网络接口所监听的端口(port)，看看是否真的启动。



```bash
netstat -[rn]       <==与路由有关的参数
netstat -[antulpc]  <==与网络接口有关的参数
选项与参数：
与路由 (route) 有关的参数说明：
-r  ：列出路由表(route table)，功能如同 route 这个指令；
-n  ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n
与网络接口有关的参数：
-a  ：列出所有的联机状态，包括 tcp/udp/unix socket 等；
-t  ：仅列出 TCP 封包的联机；
-u  ：仅列出 UDP 封包的联机；
-l  ：仅列出有在 Listen (监听) 的服务之网络状态；
-p  ：列出 PID 与 Program 的檔名；
-c  ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
```

```bash
#列出目前的路由表状态，且以 IP 及 port number 显示  
#route -n 一模一样
netstat -rn

#列出目前的所有网络联机状态，使用 IP 与 port number
netstat -an

#显示目前已经启动的网络服务
netstat -tunlp
```



服务名称与port number的对应关系在哪个文件？

/etc/services



### 检测主机名与IP的对应 host nslookup

#### host

这个指令可以查出某个主机名的IP

```bash
host [-a] hostname [server]
选项与参数：
-a ：列出该主机详细的各项主机名设定数据
[server] ：可以使用非为 /etc/resolv.conf 的 DNS 服务器 IP 来查询

host www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 220.181.112.244

host命令是向 /etc/resolv.conf 这个文件内的DNS服务器IP来查询的
```



#### nslookup

用途与host基本一样.也是通过 /etc/resolv.con 来进行DNS的查询

```bash
nslookup [-query=[type]] [hostname|IP]
选项与参数：
-query=type：查询的类型，除了传统的 IP 与主机名对应外，DNS 还有很多信息，
             所以我们可以查询很多不同的信息，包括 mx, cname 等等，
             例如： -query=mx 的查询方法！

#找出 www.google.com 的IP
nslookup www.baidu.com
Server:		192.168.1.1
Address:	192.168.1.1#53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com.
Name:	www.a.shifen.com
Address: 220.181.112.244

> cat /etc/resolv.conf 
nameserver 183.60.83.19                                                                 
nameserver 183.60.82.98

> nslookup www.baidu.com
Server:         183.60.83.19       #注意这里                                                      
Address:        183.60.83.19#53                                                         
                                                                                        
Non-authoritative answer:                                                               
www.baidu.com   canonical name = www.a.shifen.com.                                      
Name:   www.a.shifen.com                                                                
Address: 180.149.131.98 
```

## 5.3 远程连接命令与即时通信软件

### telnet

> 可以用来检测某个网站的端口是否开放
>
> telnet www.baidu.com 80

```bash
telnet [host|IP [port]]

#连接bbs站点
yum install telnet
telnet ptt.cc

#telnet 还可以用来连接到某个port(服务)上
#telnet 连接到 port 110,来查看整个port是否正确启动
telnet localhost 110

telnet localhost 25
```



## 5.4 文字接口网页浏览

### links

```bash
links [options] [URL]
选项与参数：
-anonymous [0|1]：是否使用匿名登录的意思；
-dump [0|1]     ：是否将网页的数据直接输出到 standard out 而非 links 软件功能
-dump_charset   ：后面接想要透过 dump 输出到屏幕的语系编码，big5 使用 cp950 喔

links http://www.baidu.com
```



因为你的环境可能是在 Linux 本机的 **tty1~tty6** ，所以无法显示出中文，这个时候你就得要设定为： 『LANG=en_US』之类的语系设定才行



### wget 文字接口下载器

> links 是进行网页的浏览
>
> wget 是进行网页数据的下载。wget是使用浏览器进行下载

```bash
wget [option] [网址]
选项与参数：
若想要联机的网站有提供账号与密码的保护时，可以利用这两个参数来输入喔！
--http-user=usrname
--http-password=password
--quiet ：不要显示 wget 在抓取数据时候的显示讯息
更多的参数请自行参考 man wget 吧！ ^_^

#代理proxy需要修改 /etc/wgetrc 来设置

wget http://www.baidu.com
```



### nc

nc 命令可以用来作为某些服务的检测，因为它可以连接到某个port来进行通信，此外，还可以自行启动一个port来监听其他用户的连接。

```bash
nc [-u] [IP|host] [port]
[root@www ~]# nc -l [IP|host] [port]
选项与参数：
-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；
-u ：不使用 TCP 而是使用 UDP 作为联机的封包状态

nc localhost 25
```



# 第6章 Linux网络排错

## 6.1 无法连接网络的原因分析

### 软件问题

IP参数设置、路由设置、服务器与防火墙设置



### 问题处理

1) 确认IP 

2) 确认局域网连接

​    利用 ping 来沟通两台主机（或路由器）

3) 确认对外连接

​    ping 外网

4) 确认DNS查询

​    用 nslookup、host或dig检查 www.baidu.com

5) 确认 Internet 节点

​    利用 traceroute 检查各节点是否有问题



## 疑问

:question: 1M 上行和下行是多少？

1M 不是1MB而是1Mb。大B是字节，小b是比特位。1B=8b,所以1M的实际带宽为1024/8=128K

1M = 1024KB  1024/8=128  (1byte=8bit 1Bps=8bps)

126？



:question: tty1 和 tty6  

linux的几种登录模式。tty2(alt+ctrl+f2) 6个终端

```bash
> w
23:04:42 up 73 days,  6:51,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    27.187.169.166   22:22    2.00s  0.02s  0.00s w

> ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0  1240  1238  0  80   0 - 29139 do_wai pts/0    00:00:00 bash
0 R     0  1405  1240  0  80   0 - 37204 -      pts/0    00:00:00 ps

#TTY 为登录着的终端机位置，若为远程登录则使用动态终端接口(pts/n)
#TTY 该进程在哪个终端机上运行,若与终端机无关则显示?
#tty1-tty6是本机上面的登录者程序,若为pts/0,表示网络连接进主机的进程
```

tty 终端设备的统称 (Teletypes或teletypewriters)，电传打字机，现在叫终端。终端是一种字符型设备，他有多种类型，通常使用tty来简称各种类型的终端设备。

pts/ptmx  pts(pseudo-terminal slave)是pty的实现方法,虚拟终端。

```bash
> ls /dev/pt*
0  1  2  ptmx

> w
 23:19:16 up 73 days,  7:06,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    27.187.169.166   22:22   44.00s  0.05s  0.05s -bash
root     pts/1    27.187.169.166   23:19   12.00s  0.02s  0.02s -bash
root     pts/2    27.187.169.166   23:19    4.00s  0.02s  0.00s w
```

```bash
#虚拟终端 远程连接到linux时的 /dev/pts/0
> tty
/dev/pts/0
```



:question: 浏览器输入 www.baidu.com 发生了什么

DNS解析www.baidu.com解析成ip地址，然后到应用层 > 传输层(TCP) > IP网络层(路由局域网) > 网络接口层



:question: 研究下 wireshark

[网络抓包]: https://www.cnblogs.com/doit8791/p/5730595.html

[wireshark抓包工具详细说明及操作使用]: https://blog.csdn.net/qq78069460/article/details/79153895
[wireshark基本介绍和学习TCP三次握手]: http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html
[学习Wireshark之二：数据包分析]: http://blog.51cto.com/skypegnu1/1540728
[wireshark基本用法]: http://www.cnblogs.com/dragonir/p/6219541.html
[TCP三次握手]: http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html	"看看这个 自己录制了git视频"





# 第7章 网络安全与主机基本防护

> 限制端口、网络升级与SELinux

## 7.1 网络数据包连接进入主机的流程

![image-20190512063155921](http://s.i9u.cc/image-20190512063155921.png)



### 1.经过防火墙的分析

默认Linux防火墙有两个独立存在机制，因此默认有两层防火墙：第一层是**数据包过滤式的 Net Filter 防火墙**；第二层是通过**软件管理的 TCP Wrappers 防火墙**

1. 数据包过滤式防火墙：IP Filtering 或 Net Filter

   就是 iptables 这个软件所提供的防火墙功能。主要针对 TCP/IP 的数据包头部进行过滤的机制，分析的是 OSI 的第二、三、四层，主要控制的是 MAC、IP、ICMP、TCP与UDP的端口与状态（SYN、ACK）等。

2. TCP Wrappers

   `/etc/hosts.allow` 与 `/etc/hosts.deny` 的配置文件。针对 TCP 的 Header 进行再次分析，设置机制来过滤某些 IP 或 Port，让来源端的数据包被丢弃或通过检验

### 2. 服务的基本功能

举例httpd服务：在 http.conf 配置文件里配置某些IP来源不能使用 httpd 这个服务来获取主机的数据，那么即使该IP通过了前边两层，也无法获取到主机的资源

### 3. SELinux 对网络服务的详细权限控制

### 4. 使用主机的文件系统资源

文件权限的 rwx 权限



除了上述的步骤外，还具有支持**登陆文件日志记录**的功能。尤其是 `/var/log/messages` 与 `/var/log/secure` 这些文件



---

### DDoS攻击

分布式拒绝服务攻击，通过分散在各地的僵尸计算机进行攻击，让你的系统所提供的服务被阻断而无法顺利的为其他用户提供服务的方式。最常用的是 SYN Flood 攻击法。

原理是：当主机接收了一个带有 SYN 的 TCP 数据包之后，就会启动对方要求的 Port 来等待连接，并且发送出回应数据包（带有 SYN/ACK 标志的 TCP 数据包），等待 Client 端的再次回应。

如果 Client 端发送出 SYN 的数据包后，但是将来自 Server 端的确认数据包丢弃，那么 Server 端就会一直空等。Client 端通过软件短时间持续发送这样的 SYN 数据包，Server 就会持续不断的发送确认数据包，并开启大量的 Port 在空等，等全部主机的 Port 都启用完毕，那系统就挂了。

**DDos 攻击手法不是入侵你的系统，而是让你的系统无法正常提供服务。**



主机防护的几个方向

1. 完善的登陆密码规则限制
2. 完善的主机权限设置
3. 设置自动升级与修补软件漏洞以及移除危险软件
4. SELinux
5. iptables、TCP Wrappers 强化网络防火墙
6. 利用主机监控软件（logwatch） 分析主机状况与日志文件



系统保护的几个手段

1. 随时更新系统软件
2. 限制连接端口
3. 启动 SELinux 限制网络服务的权限

## 7.2 网络自动升级软件

rpm 具有所谓的依赖性，有一些软件的基本信息，并同时记录了软件的依赖性`rpm -q`。所以分析这些基本信息并使用一些机制将这些依赖信息记录下来后，再通过一些额外的网络功能，就能够自动分析系统与修补软件之间的差异，进一步实现自动升级 => yum

### yum 软件更新、镜像站点使用原理

> CentOS 可在 yum 服务器上 下载官网给出的 rpm 表头列表数据，该数据记载了每个 rpm 软件的依赖性，也指明了 rpm 文件所放置的容器（Repository）。通过分析这些数据，CentOS 能够直接使用 yum 去下载与安装所需要的软件了

![image-20190512075806446](http://s.i9u.cc/image-20190512075806446.png)



详细流程如下：

1) 先由配置文件判断 yum Server 所在的 IP 地址

2) 连接到 yum Server 后，先下载新的 rpm 文件的表头数据

3) 分析比较用户要安装/升级的文件，并提示用户确认

4) 下载用户选择的文件到系统中的 `/var/cache/yum`，并进行实际安装



由于所下载的清单当中已经含有所有官方网站给出的 rpm 文件的表头依赖属性的关系，所以如果你想要安装的软件包括某些尚未安装的依赖性软件时，yum 会顺便帮你下载所需要的其他软件。预安装后，再安装你所实际需要的软件。

全世界如果都使用同一台 yum 服务器去下载所需要的 rpm 文件，带宽会被塞爆，可以通过镜像站点来解决。CentOS 世界各地都有镜像站点，将官网的 yum 服务器的数据复制一份，同时在镜像站点上提供同样的 yum 功能，你可以在任何一台 yum 服务器的镜像站点上面下载与安装软件。

yum 很聪明，自动分析离你的主机最近的那个镜像站点。



### yum 的功能：安装软件组、全系统更新

> yum 不仅提供在线自动升级，还用于查询、软件组的安装、整体版本的升级

```bash
# list search info install remove clean update
yum [option] [查詢的工作項目] [相關參數]
選項與參數：
option：主要的參數，包括有：
   -y ：當 yum 詢問使用者的意見時，主動回答 yes 而不需要由鍵盤輸入；

[查詢的工作項目]：由於不同的使用條件，而有一些選擇的項目，包括：
   install ：指定安裝的軟體名稱，所以後面需接『 軟體名稱 』
   update  ：進行整體升級的行為；當然也可以接某個軟體，僅升級一個軟體；
   remove  ：移除某個軟體，後面需接軟體名稱；
   search  ：搜尋某個軟體或者是重要關鍵字；
   list    ：列出目前 yum 所管理的所有的軟體名稱與版本，有點類似 rpm -qa；
   info    ：同上，不過有點類似 rpm -qai 的執行結果；
   clean   ：下載的檔案被放到 /var/cache/yum ，可使用 clean 將他移除，
             可清除的項目：packages | headers | metadata | cache 等；

# list info install remove
在[查詢的工作項目]部分還可以具有整個群組軟體的安裝方式，如下所示：
   grouplist   ：列出所有可使用的『軟體群組』，例如 Development Tools 之類的；
   groupinfo   ：後面接 group_name，則可瞭解該 group 內含的所有軟體名；
   groupinstall：這個好用！可以安裝一整組的軟體群組，相當的不錯用！
                 更常與 --installroot=/some/path 共用來安裝新系統
   groupremove ：移除某個軟體群組；
```

```bash
# 搜索 CentOS 官网提供的软件名称是否与 raid 相关的
> yum search raid

# 查询 madam 的具体功能
> yum info madam
```

yum 可以查询包含某些特殊字符的软件名称。有两种方式取得软件名称

* yum search '一些关键字'
* yum list (可列出所有的软件文件名)

然后再用正则表达式取得关键字，或者是 `yum info '软件名称'` 就能够知道该软件的用途。



#### 通过 yum 进行安装

```bash
> yum list javacc*

> yum install javacc
```

通过 yum，我们可以很轻松的安装好一个软件，并且这个软件已经主动帮我们做好依赖性属性。

CentOS 6 默认情况下，yum 下载的数据除了每个容器的表头清单文件之外，所有下载的 rpm 文件都会在安装完毕之后予以删除。如果需要保留在 `/var/cache/yum` 中，需要修改 `/etc/yum.conf` 配置文件

```bash
> vim /etc/yum.conf
[main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=1     #这一行
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
```



#### 安装软件组

```bash
# 查询系统的软件组有多少个
> yum grouplist

# Desktop Platform 内包含多少个 rpm 软件
> yum groupinfo 'Desktop Platform'

# 安装 Desktop Platform
> yum groupinstall 'Desktop Platform'
```

利用`yum groupinstall '软件组名'`可以一口气安装很多软件，不必担心某个软件忘记安装了



#### 全系统更新

使用 `yum update` 可以进行软件的安装。`yum update` 也可以直接进行同一版本的升级。

可以使用 `crontab -e` 来操作，也可以编辑 `vim /etc/crontab` 来操作，由于这个更新是**系统方面**的，可以使用 `vim /etc/crontab` 来进行命令的说明

```bash
# 每天的凌晨5:40自动更新
40 5 * * * root yum -y update && yum clean packages
```



### 修改 yum 配置文件与清除 yum 缓存

[http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/](http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/)

最重要的是 repodata 的目录。该目录就是分析 rpm 软件后所产生的**软件属性依赖数据**放置处。

```bash
# 查看原始的配置文件内容
> cat /etc/yum.repos.d/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
```

* mirrorlist

  列出这个容器可以使用的镜像站点。由于下面我们直接设置镜像站点，这行需要注释

* baseurl

  后面的值是容器的实际网址。mirrorlist 是由 yum 程序自行去获取镜像站点，basrurl 是指定固定的一个容器网址

```bash
# 修改后的配置文件
> vim /etc/yum.repos.d/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base
baseurl=http://ftp.twaren.net/Linux/CentOS/6/os/x86_64/   <==就屬它最重要！
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
# 底下其他的容器項目，請自行到高速網路中心去查詢後自己處理！

# 修改过配置文件，最好清除已有清单
> yum clean all 
```

```bash
# 列出目前 yum server 所使用的容器有哪些
# 在 /etc/yum.repos.d/ 下有多个配置文件,所以发现还有其他的容器存在
> yum repolist all
```

我们修改的是系统默认的配置文件 `/etc/yum.repos.d/CentOS-Base.repo` ，实际上，我们应该在 `/etc/yum.repos.d/` 下面新建一个文件，该扩展名必须是 `.repo` 才行。但我们修改了网址没有修改容器名称，可能有缓存存在，所以可以清除一下本机的旧数据。

```bash
> yum clean [packages|headers|all] 
選項與參數：
 packages：将已下载的 软件文件 刪除
 headers ：将下载的的 软件文件头 删除
 all     ：将 所有容器数据 都删除
 
 # 删除已下载过的所有容器的相关数据(含软件本身与列表)
 > yum clean all
```

## 7.3 限制连接端口 Port

当我们启用一个 daemon 时，就会触发主机的端口进行监听的动作。

当启动一个网络服务时，这个服务会依据 TCP/IP 的相关通信协议启动一个端口进行监听，这就是 TCP/UDP 数据包的 Port 端口了。第2章中我们知道网络连接是双向的，服务器端需要启动一个监听的端口，客户端需要随机启动一个端口来接收响应的数据才行。

port 的启动与服务有关。服务与 port 对应的文件是 /etc/services

### 端口的查看 netstat nmap

* netstat 在本机上以自己的程序检测自己的端口
* nmap 通过网络的检测软件辅助，可检测非本机上的其他网络主机



```bash
# 列出正在监听的网络服务
> netstat -tunl

# 列出已连接的网络连接状态
> netstat -tun

# 删除已建立或在监听当中的连接
> netstat -tunp  #pid = 1342

# 不能用 killall,否则容易删除
> kill -9 1342
```



```bash
# nmap
> yum install nmap
> nmap localhost
```



# 第8章 路由的概念与路由器设置

每一台主机都有自己的路由表

```bash
> route -n
Kernel IP routing table
Destination  Gateway        Genmask         Flags Metric Ref  Use Iface
192.168.1.0  0.0.0.0        255.255.255.0   U     0      0      0 eth0 <== 1
169.254.0.0  0.0.0.0        255.255.0.0     U     1002   0      0 eth0 <== 2
0.0.0.0      192.168.1.254  0.0.0.0         UG    0      0      0 eth0 <== 3
```

Linux 系统下的路由表是由小网络排列到大网络，路由是由『 192.168.1.0/24 --> 169.254.0.0/16 --> 0.0.0.0/0 (默认路由) 』來排列的



# 第9章 防火墙与 NAT 服务器

Linux 的防火墙主要是通过 Netfilter 与 TCP Wrappers 两个机制来管理。

Netfilter 防火墙机制，可以实现私有 IP 的主机上网（IP路由器功能），并且也能够让 Internet 连接内部的私有 IP 所架设的 Linux 服务器（DNAT功能）。



## 9.1 认识防火墙

防火墙就是通过定义一些有顺序的规则，并管理进入到网络内的主机数据数据包的一种机制。广义的说，只要能够分析与过滤进出我们管理的网络的数据包的数据，就称为防火墙。

Netfilter 是数据包过滤式的防火墙机制，可以通过 iptables 命令的方式进行规则的排序与修改

### 为何需要防火墙

数据包进入主机时，会通过防火墙、服务器软件程序、SELinux与文件系统权限。

防火墙最大的功能就是帮助你限制某些服务的访问来源。重要任务如下：

* 切割被信任（子域）与不被信任（Internet）的网段
* 划分出可提供 Internet 的服务与必须受保护的服务
* 分析出可接受与不可接受的数据包状态

### 防火墙的类别

依据防火墙管理范围来划分

* 网络型
* 单一主机型
  * 数据包过滤型的 Netfilter
  * 依据服务软件程序作为分析的 TCP Wrappers



Netfilter（数据包过滤机制）

数据包过滤就是分析进入主机的网络数据包，将数据包的**头部数据**提取出来进行分析，以决定该连接为放行或阻挡的机制。包括硬件地址MAC、软件地址IP、TCP、UDP、ICMP 等数据包的信息都可以过滤分析。主要分析的是 OSI七层协议的 2、3、4层。

Linux 内核内建了 Netfilter 这个机制，而 Netfilter 提供了 iptables 这个软件作为防火墙数据包过滤的命令。



TCP Wrappers（程序管理）

这种机制主要分析谁对某程序进行访问，然后通过规则去分析该服务器程序谁能够连接，谁不能连接。

由于主要是通过分析服务器程序来管理，因此**与启动的端口无关，只与程序的名称有关**。

举例：FTP 可以启动在非正规的 port 21 进行监听，当你通过 Linux 内建的 TCP Wrappers 限制 FTP 时，那么你只要知道 FTP 的软件名称（vsftpd），然后对它进行限制，且不管 FTP 启动在哪个端口，都会被该规则管理的。



## 9.2 TCP Wrappers

TCP Wrappers 通过客户端想要链接的程序文件名，然后分析客户端的IP，看看是否需要放行。

TCP Wrappers 是通过 `/etc/hosts.allow`、`/etc/hosts.deny` 来管理类似防火墙的机制。只有下面的软件才能够通过这两个文件来管理防火墙规则：

* 由 super daemon（xinetd）所管理的服务
* 支持 libwrap.so 模块的服务



```bash
<service(program_name)> : <IP, domain, hostname> 
<服务   (也就是程序名称)> : <IP 或域 或主机名>
# 上头的 > < 是不存在与配置文件中的
```



防火墙的规则是有顺序的：

* 先以 /etc/hosts.allow 进行优先比对，该规则符合就予以放行
* 再以 /etc/hosts.deny 比对，规则符合就予以抵挡
* 若不在这两个文件内，亦即规则都不符合，最终则予以放行

```bash
# 开放本机的127.0.0.1进行任何本机的服务
# 局域网(192.168.1.0/24)可以使用rsync,同时10.0.0.100也可以使用rsync
# 其他来源不允许使用rsync
> vim /etc/hosts.allow
ALL: 127.0.0.1    <== 这就是本机全部的服务都接受
rsync: 192.168.1.0/255.255.255.0 10.0.0.100

> vim /etc/hosts.deny
rsync: ALL
```

TCP Wrappers 不支持 192.168.0.1/24 这种网络，只支持 Netmask 的地址显示方式。



## 9.3 数据包过滤软件 iptables

### 数据包进入流程：规则顺序的重要性

iptables 利用的是 数据包过滤的机制，会分析数据包的报头数据。根据报头数据与定义的规则来决定该数据包是否进入主机或者被丢弃。根据数据包的分析资料 "比对" 预先定义的规则内容，若数据包数据与规则内容相同则进行动作，否则就继续下一条规则的比对。

当一个网络数据包要进入主机之前，会先经过 Netfilter 进行检查，就是 iptables 的规则。检查通过则接受（ACCPET） 进入本机取得资源，如果检查不通过，则可能予以丢弃（DROP）。规则是有顺序的。如果规则都不符合，则会走默认操作（数据包策略Policy）。



### iptables 的表格（table）与链（chain）

防火墙软件里有多个表格（table），每个表格都定义出自己的默认策略与规则，且每个表格的用途都不相同。

默认情况下，Linux 的 iptables 至少有3个表格，包括管理本机进出的 Filter、管理后端主机的 NAT、管理特殊标志使用的 Mangle



![image-20190513225745820](http://s.i9u.cc/image-20190513225745820.png)



Filter（过滤器）：主要跟进入 Linux 主机的数据包有关，是默认的 table

​	INPUT : 主要与想要进入 Linux 主机的数据包有关

​	OUTPUT : 主要与 Linux 本机所要送出的数据包有关

​	FORWARD : 与 Linux 本机没有关系，可以传递数据包到后端的计算机中，与 NAT 的 table 有关



NAT（地址转换）：这个表格主要用来进行来源与目的地的 IP 或 port 的转换，与 Linux 主机无关，主要与 Linux 主机后的局域网内计算机有关。



Mangle（破坏者）：这个表格主要与特殊的数据包的路由标志有关



![image-20190513231412073](http://s.i9u.cc/image-20190513231412073.png)



网络是双向的，进入的数据包需要路由判断，送出的数据包也要进行路由判断。

与本机最有关的是 Filter 表格内的 INPUT 与 OUTPUT 链。



### 本机的 iptables 语法

iptables 至少有3个默认的 table（Filter、NAT、Mangle），常用的是本机的 Filter 表格，这也是默认表格。

防火墙的设置主要使用 iptables 命令，因此只能让 root 使用 iptables，不论是设置还是查看防火墙规则。



#### 规则的查看与清除

```bash
iptables [-t tables] [-L] [-nv]    tvnL
选项与参数：
-t ：後面接 table ，例如 nat 或 filter ，若省略此項目，則使用預設的 filter
-L ：列出目前的 table 的規則
-n ：不進行 IP 與 HOSTNAME 的反查，顯示訊息的速度會快很多！
-v ：列出更多的資訊，包括通過該規則的封包總位元數、相關的網路介面等
```

```bash
# 列出 filter table 3条链的规则
> iptables -L -n
Chain INPUT (policy ACCEPT)   <==針對 INPUT 鏈，且預設政策為可接受
target  prot opt source     destination <==說明欄
ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0   state RELATED,ESTABLISHED <==第 1 條規則
ACCEPT  icmp --  0.0.0.0/0  0.0.0.0/0                             <==第 2 條規則
ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0                             <==第 3 條規則
ACCEPT  tcp  --  0.0.0.0/0  0.0.0.0/0   state NEW tcp dpt:22      <==以下類推
REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited

Chain FORWARD (policy ACCEPT)  <==針對 FORWARD 鏈，且預設政策為可接受
target  prot opt source     destination
REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT)  <==針對 OUTPUT 鏈，且預設政策為可接受
target  prot opt source     destination
```

```bash
# 列出 nat table 3条链的规则
> iptable -t nat -L -n
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```



iptables-save 会列出完整的防火墙规则，只是并没有格式化输出。

```bash
iptables-save [-t table]
選項與參數：
-t ：可以僅針對某些表格來輸出，例如僅針對 nat 或 filter 等等
```

```bash
> iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011
*filter                      <==星號開頭的指的是表格，這裡為 filter
:INPUT ACCEPT [0:0]          <==冒號開頭的指的是鏈，三條內建的鏈
:FORWARD ACCEPT [0:0]        <==三條內建鏈的政策都是 ACCEPT 囉！
:OUTPUT ACCEPT [680:100461]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT <==針對 INPUT 的規則
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT  <==這條很重要！針對本機內部介面開放！
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited <==針對 FORWARD 的規則
COMMIT
# Completed on Fri Jul 22 15:51:52 2011
```



```bash
iptables [-t tables] [-FXZ]    XZF
選項與參數：
-F ：清除所有的已訂定的規則；
-X ：殺掉所有使用者 "自訂" 的 chain (應該說的是 tables ）囉；
-Z ：將所有的 chain 的計數與流量統計都歸零

範例：清除本機防火牆 (filter) 的所有規則
[root@www ~]# iptables -F
[root@www ~]# iptables -X
[root@www ~]# iptables -Z
```



#### 定义默认策略

默认策略是指：当数据包不在我们设置的规则之内时，该数据包的通过与否，是以 Policy 的设置为准。

```bash
iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]
選項與參數：
-P ：定義政策( Policy )。注意，這個 P 為大寫啊！
ACCEPT ：該封包可接受
DROP   ：該封包直接丟棄，不會讓 client 端知道為何被丟棄。
```

```bash
# 默认是 filter 表格
[root@www ~]# iptables -P INPUT   DROP
[root@www ~]# iptables -P OUTPUT  ACCEPT
[root@www ~]# iptables -P FORWARD ACCEPT
[root@www ~]# iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
# Completed on Fri Jul 22 15:56:34 2011
# 由於 INPUT 設定為 DROP 而又尚未有任何規則，所以上面的輸出結果顯示：
# 所有的封包都無法進入你的主機！是不通的防火牆設定！(網路連線是雙向的)

# 设置 NAT table 的 PREROUTING 链为可接受
iptables -t nat -P PREROUTING ACCEPT
```



#### 数据包基础：IP、网络及接口设备

```bash
# AIpsdj
> iptables [-AI 鏈名] [-io 網路介面] [-p 協定] \
> [-s 來源IP/網域] [-d 目標IP/網域] -j [ACCEPT|DROP|REJECT|LOG]
選項與參數：
-AI 鏈名：針對某的鏈進行規則的 "插入" 或 "累加"
    -A ：新增加一條規則，該規則增加在原本規則的最後面。例如原本已經有四條規則，
         使用 -A 就可以加上第五條規則！
    -I ：插入一條規則。如果沒有指定此規則的順序，預設是插入變成第一條規則。
         例如原本有四條規則，使用 -I 則該規則變成第一條，而原本四條變成 2~5 號
    鏈 ：有 INPUT, OUTPUT, FORWARD 等，此鏈名稱又與 -io 有關，請看底下。

-io 網路介面：設定封包進出的介面規範
    -i ：封包所進入的那個網路介面，例如 eth0, lo 等介面。需與 INPUT 鏈配合；
    -o ：封包所傳出的那個網路介面，需與 OUTPUT 鏈配合；

-p 協定：設定此規則適用於哪種封包格式
   主要的封包格式有： tcp, udp, icmp 及 all 。

-s 來源 IP/網域：設定此規則之封包的來源項目，可指定單純的 IP 或包括網域，例如：
   IP  ：192.168.0.100
   網域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。
   若規範為『不許』時，則加上 ! 即可，例如：
   -s ! 192.168.100.0/24 表示不許 192.168.100.0/24 之封包來源；

-d 目標 IP/網域：同 -s ，只不過這裡指的是目標的 IP 或網域。

-j ：後面接動作，主要的動作有接受(ACCEPT)、丟棄(DROP)、拒絕(REJECT)及記錄(LOG)
```

```bash
# 设置 lo 为信任的设备，进出 lo 的数据包都予以接受
> iptables -A INPUT -i lo -j ACCEPT
```

```bash
# 只要是内网的 192.168.100.0/24 数据包都接受
> iptables -A INPUT -i eth1 -s 192.168.100.0/24 -j ACCEPT

# 只要是来自 192.168.100.10 就接受,但来自 192.168.100.230 丢弃
> iptables -A INPUT -i eth1 -s 192.168.100.10 -j ACCEPT
> iptables -A INPUT -i eth1 -s 192.168.100.230 -j DROP

> iptables-save
# Generated by iptables-save v1.4.7 on Fri Jul 22 16:00:43 2011
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [17:1724]
-A INPUT -i lo -j ACCEPT
-A INPUT -s 192.168.100.0/24 -i eth1 -j ACCEPT
-A INPUT -s 192.168.100.10/32 -i eth1 -j ACCEPT
-A INPUT -s 192.168.100.230/32 -i eth1 -j DROP
COMMIT
# Completed on Fri Jul 22 16:00:43 2011
```

```bash
# 记录某个规则的记录
# 只要数据包来自 192.168.2.200这个IP时,该数据包的相关信息就会写入内核日志文件(/var/log/messages).然后继续比对后续的规则.LOG动作只进行日志记录,不影响规则的比对
> iptables -A INPUT -s 192.168.2.200 -j LOG
> iptables -L -n
target prot opt source         destination
LOG    all  --  192.168.2.200  0.0.0.0/0   LOG flags 0 level 4
```

#### TCP、UDP规则比对：针对端口设置

```bash
> iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \
> [-s 来源IP/网络] [--sport 端口范围] \
> [-d 目标IP/网络] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]
选项与参数：
--sport 端口范围：限制来源的端口号码，端口号可以是连续的，例如 1024:65535
--dport 端口范围：限制目标的端口号码。
```

因为仅有 TCP 与 UDP 数据包具有端口，因此要想使用 `--dport` 和 `--sport` 时，需要加上 `-p tcp` 或 `-p udp` 参数才行

```bash
# 想要进入本机 port 21 的数据包阻挡掉
> iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP

# TCP数据包还有特殊的标志 主动连接SYN标志
# 将来自任何地方来源port 1:1023 的主动连接到本机端的 1:1023 连接丢弃
iptables -A INPUT -i eth0 -p tcp --sport 1:1023 --dport 1:1023 --syn -j DROP
```



#### iptables 外挂模块：mac与state

可以通过一个状态模块来分析：**想要进入的数据包是否为刚刚发出去的响应**，如果是刚刚发出去的响应，就可以予以接受放行。

```bash
iptables -A INPUT [-m state] [--state 狀態]
選項與參數：
-m ：一些 iptables 的外掛模組，主要常見的有：
     state ：狀態模組
     mac   ：網路卡硬體位址 (hardware address)
--state ：一些封包的狀態，主要有：
     INVALID    ：無效的封包，例如資料破損的封包狀態
     ESTABLISHED：已經連線成功的連線狀態；
     NEW        ：想要新建立連線的封包狀態；
     RELATED    ：這個最常用！表示這個封包是與我們主機發送出去的封包有關

範例：只要已建立或相關封包就予以通過，只要是不合法封包就丟棄
[root@www ~]# iptables -A INPUT -m state \
> --state RELATED,ESTABLISHED -j ACCEPT
[root@www ~]# iptables -A INPUT -m state --state INVALID -j DROP
```

```bash
範例：針對區域網路內的 aa:bb:cc:dd:ee:ff 主機開放其連線
[root@www ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff \
> -j ACCEPT
選項與參數：
--mac-source ：就是來源主機的 MAC 啦！
```



---

防火墙的设置规则：

1. 规则归零：清除所有已存在的规则（iptables -F）

2. 默认策略：INPUT这个链定义为DROP，其他默认为ACCEPT

3. 信任本机：lo 设置为信任设备

4. 回应数据包：本机主动向外发出请求而响应的数据包可以进入本机

5. 信任用户

   

```bash
# 1. 清除規則
iptables -F
iptables -X
iptables -Z

# 2. 設定政策
iptables -P   INPUT DROP
iptables -P  OUTPUT ACCEPT
iptables -P FORWARD ACCEPT

# 3~5. 制訂各項規則
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT
#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT

# 6. 寫入防火牆規則設定檔
/etc/init.d/iptables save
```



# 第10章 合法的主机名-域名

DNS 的功能就是 **将计算机主机的名称转译成 IP**，让主机名对应IP的解析上。

![image-20190514065146013](http://s.i9u.cc/image-20190514065146013.png)



主机名的目的在辅助人们记忆 TCP/IP 的 IP 数值

主机名与IP的对应，由早期的 /etc/hosts 变更为 DNS 系统来记录



0526 继续读书呀



# 第11章 远程连接服务器 SSH

远程连接服务器通过文字或图形接口的方式来远程登陆系统，让你在远程的终端前面登陆 Linux 主机以取得可操作主机的接口（shell），而登陆后的操作感觉上就像坐在系统前面一样！



**数据的明文传输与加密传输**

明文传输：当我们的数据包在网络上传输时，该数据包的内容为数据的原始格式

加密传输：通过 SSH 协议传输信息时，因为数据是加密过的，所以信息比较安全



## 11.1 文件接口连接服务器 SSH服务器

> SSH 是 Secure Shell Protocol 的简写（安全的壳程序协议），可以通过数据包加密技术将等待传输的数据包加密后再传输到网络上。



SSH 协议提供了两个服务器的功能

* 类似 Telnet 的远程连接使用 Shell 的服务器，称为 SSH
* 类似 FTP 服务的 Sftp-Server，提供更安全的 FTP 服务



## 11.2 连接加密技术

目前常见的网络数据包加密技术通常是 **"非对称密钥系统"** 。主要是通过两把不一样的公钥和私钥（Public and Private Key）来进行加密与解密的过程。由于这两把钥匙的作用是提供数据加解密的，所以在同一个方向的连接中，这两把钥匙是需要成对的

* 公钥（Public Key） 提供给远程主机进行数据加密的行为。所有人都可以获得公钥来将数据加密
* 私钥（Private Key）远程主机使用你的公钥加密的数据，在本地端能够使用私钥进行解密。私钥很重要，不能外流，只能保存在自己的主机上。

由于每台主机都有自己的密钥（公钥与私钥），且公钥用来加密而私钥用来解密，其中私钥不可外流，但因为网络连接是双向的，所以，每个人应该都要有对方的"公钥"才对。

客户端视角：取得服务器端的公钥，然后将自己的公钥发送给服务器端，最终客户端上面的密钥是：服务器的公钥 + 客户端自己的私钥 组成。



SSH 协议版本有两种，Version 1 与 Version 2。Version 2 加上了连接检测的机制，可以避免连接期间被插入恶意的攻击码，因此比 Version 1 更加安全。推荐



![](http://cn.linux.vbird.org/linux_server/0310telnetssh_files/ssh-keypair2.gif)



1. 服务器建立公钥文件：第一次启动 SSHD 服务时，该服务会主动去找 `/etc/ssh/ssh_host*` 文件，如果没有则自动生成。
2. 客户端主动连接要求：客户端想要连接到 SSH 服务器，需要用合适的客户端程序来连接（putty）
3. 服务器传送公钥文件给客户端：接收到客户端的要求后，服务器将第一个步骤取得的公钥文件传送给客户端使用（明码传送，公钥可以给大家使用）
4. 客户端记录/比对服务器的公钥数据及随机计算自己的公私钥
   1. 如果客户端第一次连接到此服务器，会将服务器的公钥数据记录到客户端的用户主目录内的 `~/.ssh/known_hosts`
   2. 如果已经记录过该服务器的公钥数据，则客户端会去比对此次接收到的与之前的记录是否有差异。若开始接收公钥数据，则开始计算客户端自己的公私钥数据
5. 返回客户端的公钥数据到服务器端：用户将自己的公钥数据传送给服务器。此时服务器具有服务器的私钥和客户端的公钥，而客户端具有服务器的公钥和客户端自己的私钥。此次连接的服务器与客户端的密钥系统（公钥+私钥）并不一样，所以称为**非对称式密钥系统** 
6. 开始双向加解密：
   1. 服务器到客户端：服务器传送数据时，拿用户的公钥加密后进行发送，客户端接收后，用自己的私钥解密
   2. 客户端到服务器：客户端传送数据时，拿服务器的公钥加密后进行发送，服务器接收后，用服务器的私钥解密



通过第4步，客户端的密钥是随机运算产生与本次连接当中的，所以这次的连接与下次的连接密钥可能会不一样。此外客户端的用户主目录下的 `~/.ssh/known_hosts` 中会记录曾经连接过的主机的 Public Key，用于确认我们已连接上正确的服务器。



如何产生新的服务器端的 SSH 公钥和私钥呢？

由于服务器提供的公钥和私钥都放置在 `/etc/ssh/ssh_host*` 可以这样做

```bash
> rm /etc/ssh/ssh_host*    #删除密钥文件

> /etc/init.d/sshd restart 
正在停止 sshd:                         [  确定  ]
正在产生 SSH1 RSA 主机密钥:            [  确定  ] <==底下三个步骤重新产生密钥！
正在产生 SSH2 RSA 主机密钥:            [  确定  ]
正在产生 SSH2 DSA 主机密钥:            [  确定  ]
正在激活 sshd:                         [  确定  ]

> ll /etc/ssh/ssh_host*
-rw-------. 1 root root  668 Jul 25 11:35 /etc/ssh/ssh_host_dsa_key
-rw-r--r--. 1 root root  590 Jul 25 11:35 /etc/ssh/ssh_host_dsa_key.pub
-rw-------. 1 root root  963 Jul 25 11:35 /etc/ssh/ssh_host_key
-rw-r--r--. 1 root root  627 Jul 25 11:35 /etc/ssh/ssh_host_key.pub
-rw-------. 1 root root 1675 Jul 25 11:35 /etc/ssh/ssh_host_rsa_key
-rw-r--r--. 1 root root  382 Jul 25 11:35 /etc/ssh/ssh_host_rsa_key.pub
# 看一下上面输出的日期与档案的建立时间，刚刚建立的新公钥、私钥系统！
```

### 启动 SSH 服务

```bash
> /etc/init.d/sshd restart
> netstat -tlnp | grep ssh
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID/Program name
tcp        0      0 :::22          :::*             LISTEN  1539/sshd
```



### SSH 客户端连接程序—Linux用户

SSH 在 Client 端使用的是 SSH 这个指令

```bash
> ssh [-f] [-o 参数项目] [-p 非正规埠口] [账号@]IP [指令]
选项与参数：
-f ：需要配合后面的 [指令] ，不登入远程主机直接发送一个指令过去而已；
-o 参数项目：主要的参数项目有：
	ConnectTimeout=秒数 ：联机等待的秒数，减少等待的时间
	StrictHostKeyChecking=[yes|no|ask]：预设是 ask，若要让 public key 主动加入 known_hosts ，则可以设定为 no 即可。
-p ：如果你的 sshd 服务启动在非正规的埠口 (22)，需使用此项目；
[指令] ：不登入远程主机，直接发送指令过去。但与 -f 意义不太相同。
```

```bash
#直接连接登陆到对方的主机,以本机为例
ssh 127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
RSA key fingerprint is eb:12:07:84:b9:3b:3f:e4:ad:ba:f1:85:41:fc:18:3b.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '127.0.0.1' (RSA) to the list of known hosts.
root@127.0.0.1's password: <==在这里输入 root 的密码即可！
Last login: Mon Jul 25 11:36:06 2011 from 192.168.1.101

[root@www ~]# exit  <==离开这次的 ssh 联机
# 由于 ssh 后面没有加上账号，因此预设使用当前的账号来登入远程服务器
```



一般使用 SSH 登陆远程主机，采用 "SSH 账号名称 IP" 的格式。为了习惯，可以使用类似 E-mail 的方式登陆远程主机。`ssh student@127.0.0.1` 

上面的信息中，开头 RSA 的那行后面接的就是 **远程服务器的公钥指纹码**，如果确认没问题，输入 Yes 将该指纹码写入服务器公钥记录文件 `~/.ssh/konwn_hosts`，以便对比该服务器的正确性。

```bash
# 2. 使用 student 账号登入本机
[root@www ~]# ssh student@127.0.0.1
student@127.0.0.1's password:
[student@www ~]$ exit
# 由于加入账号，因此切换身份成为 student 了！另外，因为 127.0.0.1 曾登入过，
# 所以就不会再出现提示你要增加主机公钥的讯息啰！

# 3. 登入对方主机执行过指令后立刻离开的方式：
[root@www ~]# ssh student@127.0.0.1 find / &> ~/find1.log
student@localhost's password:
# 此时你会发现怎么画面卡住了？这是因为上头的指令会造成，你已经登入远程主机，
# 但是执行的指令尚未跑完，因此你会在等待当中。那如何指定系统自己跑？

# 4. 与上题相同，但是让对方主机自己跑该指令，你立刻回到近端主机继续工作：
[root@www ~]# ssh -f student@127.0.0.1 find / &> ~/find1.log
# 此时你会立刻注销 127.0.0.1 ，但 find 指令会自己在远程服务器跑喔！
```

如果想要让远程主机进行关机的指令，如果不加上 -f 的参数，那会等待对方主机关机完毕后才讲本机断开连接。因此，加上 -f 指定远程主机自己关机，而不需要在等待。 `ssh -f root@ip shutdown -h now`

```bash
# 5. 删除掉 known_hosts 后，重新使用 root 联机到本机，且自动加上公钥记录
[root@www ~]# rm ~/.ssh/known_hosts
[root@www ~]# ssh -o StrictHostKeyChecking=no root@localhost
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
root@localhost's password:
# 如上所示，不会问你 yes 或 no 啦！直接会写入 ~/.ssh/known_hosts 当中！
```





### 服务器公钥记录文件: `~/.ssh/known_hosts` 

等你登陆远程服务器时，本机会主动利用接收到的服务器的 Public Key 去比对 `~/.ssh/known_hosts` 有无相关的公钥，然后进行下面的操作：

* 若接收到的公钥尚未记录，则询问用户是否记录。Yes则写入 `~/.ssh/known_hosts` 且执行后续工作；若No，则不写入该文件，并退出登陆工作
* 若接收到的公钥已有记录，则比对记录是否相同，若相同，则继续登陆。若不相同，则出现警告信息，且离开登陆的动作。



### 文件异地直接复制 SCP

```bash
[root@www ~]# scp [-pr] [-l 速率] file  [账号@]主机:目录名 <==上传
[root@www ~]# scp [-pr] [-l 速率] [账号@]主机:file  目录名 <==下载
选项与参数：
-p ：保留原本档案的权限数据；
-r ：复制来源为目录时，可以复制整个目录 (含子目录)
-l ：可以限制传输的速度，单位为 Kbits/s ，例如 [-l 800] 代表传输速限 100Kbytes/s

# 1. 将本机的 /etc/hosts* 全部复制到 127.0.0.1 上面的 student 家目录内
[root@www ~]# scp /etc/hosts* student@127.0.0.1:~
student@127.0.0.1's password: <==输入 student 密码
hosts                        100%  207         0.2KB/s   00:00
hosts.allow                  100%  161         0.2KB/s   00:00
hosts.deny                   100%  347         0.3KB/s   00:00
# 文件名显示                   进度  容量(bytes) 传输速度  剩余时间
# 你可以仔细看，出现的讯息有五个字段，意义如上所示。

# 2. 将 127.0.0.1 这部远程主机的 /etc/bashrc 复制到本机的 /tmp 底下
[root@www ~]# scp student@127.0.0.1:/etc/bashrc /tmp
```

**上传和下载的重点是那个冒号:**  连接在冒号后面的就是远程主机的文件。如果要复制目录的话，加上 -r 选项

* 冒号在前，代表从远程主机下载下来
* 冒号在后，代表本机数据上传

**前 => 下载   后 => 上传     前下后上**



## 11.3 SSHD 服务器详细配置

SSHD 服务器的详细设置都放在 `/etc/ssh/sshd_config` 配置文件中。



```bash
> vim /etc/ssh/sshd_config
# Port 22
# PidFile /var/run/sshd.pid

# HostKey /etc/ssh/ssh_host_rsa_key  SSH version 2 使用的 RSA 私钥

# 4.1 登入设定部分
# PermitRootLogin yes
# 是否允许 root 登入！预设是允许的，但是建议设定成 no！

# PubkeyAuthentication yes
# AuthorizedKeysFile      .ssh/authorized_keys
# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。
# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内

PasswordAuthentication yes
# 密码验证当然是需要的！所以这里写 yes 啰！

# PermitEmptyPasswords no
# 若上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，
# 这个项目在是否允许以空的密码登入！当然不许！

# IgnoreUserKnownHosts no
# 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容？
# 当然不要忽略，所以这里就是 no 啦！
```

建议将 root 的登陆权限取消，并将 SSH 版本设定为 2。如果修改过上面这个文件（`/etc/ssh/sshd_config`）,那么就必须重新启动一次 SSHD 才行，`/etc/init.d/sshd restart`



## 11.4 制作不用密码可立即登陆的 SSH 用户

SSH 可以使用 SCP 进行网络复制，可以将 SCP 的指令放置在 crontab 服务中吗？

默认是不允许的，必须远程登陆，与 SCP 互动的输入密码才行。但是我们可以用 **密钥认证系统** 来处理



SSH 可以使用密钥系统来比对数据，并且提供用户数据的加密功能，可以利用这个 Key 就提供用户自己进入主机，而不需要密码。

可以将 Client 产生的 Key 复制到 Server 中，以后 Client 登陆 Server 时，由于两者在 SSH 要连接的信号传递中已经比对过 Key ，所以可以立即进入数据传输接口中，不需要再输入密码。步骤如下（**类似github**）

1. 客户端建立两把钥匙：私钥比较重要。所以这两把钥匙得在发起连接的客户端配置才对。利用 `ssh-keygen` 这个命令
2. 客户端放置好私钥文件：将 Private Key 放在 Client 上面的用户主目录中，也就是 `$HOME/.ssh/` ，注意权限
3. 将公钥放置到服务器端的正确目录与文件中：将 Public Key 放在任何一个想要登陆的服务器端某用户主目录内的 `.ssh/` 里边的认证文件中



![](http://cn.linux.vbird.org/linux_server/0310telnetssh_files/authorized_keys.gif)

---

1. 客户端建立两把钥匙。如果不指定特殊的算法，默认以 RSA 算法来处理

   ```bash
   > ssh-keygen [-t rsa|dsa] <==可选 rsa 或 dsa
   
   > ssh-keygen  <==用默认的方法建立密钥
   Generating public/private rsa key pair.
   Enter file in which to save the key (/home/vbirdtsai/.ssh/id_rsa): <==按 enter
   Created directory '/home/vbirdtsai/.ssh'. <==此目录若不存在则会主动建立
   Enter passphrase (empty for no passphrase): <==按 Enter 不给密码
   Enter same passphrase again: <==再输入一次 Enter 吧！
   Your identification has been saved in /home/vbirdtsai/.ssh/id_rsa. <==私钥档
   Your public key has been saved in /home/vbirdtsai/.ssh/id_rsa.pub. <==公钥档
   The key fingerprint is:
   0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 vbirdtsai@clientlinux.centos.vbird
   
   > ls -ld ~/.ssh; ls -l ~/.ssh
   drwx------. 2 vbirdtsai vbirdtsai 4096 2011-07-25 12:58 /home/vbirdtsai/.ssh
   -rw-------. 1 vbirdtsai vbirdtsai 1675 2011-07-25 12:58 id_rsa      <==私钥档
   -rw-r--r--. 1 vbirdtsai vbirdtsai  416 2011-07-25 12:58 id_rsa.pub  <==公钥档
   ```

   当我执行 `ssh-keygen` 时候，会在家目录下的 `.ssh/` 目录下产生所需的两个 Keys，分别是 私钥（id_rsa）和公钥（id_rsa.pub）。`~/.ssh` 目录的权限必须是 700 才行

2. 将公钥文件数据上传到服务器上

   ```bash
   #用scp来复制文件 冒号的意义是:前下后上
   scp ~/.ssh/id_rsa.pub dmtsai@192.168.100.254:~
   ```

3. 将公钥放置服务器端正确目录与文件名

   在 `/etc/ssh/sshd_config` 配置文件中的 `AuthorizedKeysFile` 的值就是在指定公钥数据应该要放置的文件名。我们将刚刚上传的 `id_rsa.pub` 数据附加到 `authorized_keys` 这个文件内

   ```bash
   # 1. 建立 ~/.ssh 档案，注意权限需要为 700 喔！
   [dmtsai@www ~]$ ls -ld .ssh
   ls: .ssh: 没有此一档案或目录
   # 由于可能是新建的用户，因此这个目录不存在。不存在才作底下建立目录的行为
   
   [dmtsai@www ~]$ mkdir .ssh; chmod 700 .ssh
   [dmtsai@www ~]$ ls -ld .ssh
   drwx------. 2 dmtsai dmtsai 4096 Jul 25 13:06 .ssh
   # 权限设定中，务必是 700 且属于使用者本人的账号与群组才行！
   
   # 2. 将公钥档案内的数据使用 cat 转存到 authorized_keys 内
   [dmtsai@www ~]$ ls -l *pub
   -rw-r--r--. 1 dmtsai dmtsai 416 Jul 25 13:05 id_rsa.pub <==确实有存在
   
   [dmtsai@www ~]$ cat id_rsa.pub >> .ssh/authorized_keys
   [dmtsai@www ~]$ chmod 644 .ssh/authorized_keys
   [dmtsai@www ~]$ ls -l .ssh
   -rw-r--r--. 1 dmtsai dmtsai 416 Jul 25 13:07 authorized_keys
   # 这个档案的权限设定中，就得要是 644 才可以！不可以搞混了！
   ```

   

成功之后，通过以下来测试一下

```bash
[vbirdtsai@clientlinux ~]$ scp /etc/hosts* dmtsai@192.168.100.254:~
hosts                                        100%  187     0.2KB/s   00:00
hosts.allow                                  100%  161     0.2KB/s   00:00
hosts.deny                                   100%  347     0.3KB/s   00:00
# 你会发现，原本会出现的那个密码提示数据不会出现了喔！

[vbirdtsai@clientlinux ~]$ ssh dmtsai@192.168.100.254 "ls -l"
-rw-r--r--. 1 dmtsai dmtsai 196 2011-07-25 13:09 hosts
-rw-r--r--. 1 dmtsai dmtsai 370 2011-07-25 13:09 hosts.allow
-rw-r--r--. 1 dmtsai dmtsai 460 2011-07-25 13:09 hosts.deny
-rw-r--r--. 1 dmtsai dmtsai 416 2011-07-25 13:05 id_rsa.pub
# 确实有复制到对方去了！有显示出正确的远程数据哩！
```



建立密钥系统的步骤谨记：

* Client 必须制作出 Public & Private 这两把 Keys，且 Private_key 需要放到 `~/.ssh` 内
* Server 必须要有 PublicKey，且放置到用户家目录下的 `~/.ssh/authorized_keys`，同时目录的权限 (.ssh/) 必须是 700 而且文件权限必须是 644，同时文件的拥有者与群组必须与该账号吻合。

## 11.5 以rsync进行同步镜像备份

rsync 作为一个相当棒的异地备份系统的备份指令。

rsync 传输方式至少可以用三种方式来运作：

* 在本机上直接运行，用法与 cp 几乎一模一样

  ```bash
  #将 /etc/ 的数据备份到 /tmp/etc 内
  rsync -av /etc /tmp
  ```

* 通过 rsh 或 ssh 的方式在 Server/Client 之间进行传输数据

  ```bash
  #将rsh.server的 /etc/ 备份到本机的 /tmp 内
  rsync -av -e ssh user@rsh.server:/etc /tmp
  ```

* 直接通过 rsync 提供的服务(daemon)来传输，此时rsync主机需要启动 873 端口

  * 必须在 server 端启动 rsync，看 `/etc/xinetd.d/rsync` 即可
  * 编辑 `/etc/rsyncd.conf` 配置文件
  * 设定好 client 端联机的密码数据
  * 在 client 端可以利用 `rsync -av user@hostname::/dir/path /local/path`



三种模式的差异在于有没有冒号（:），本地传输不需要冒号；透过 ssh 或 rsh 时，需要一个冒号`;`，如果是通过 rsync daemon的话，需要两个冒号 `::`

```bash
[root@www ~]# rsync [-avrlptgoD] [-e ssh] [user@host:/dir] [/local/path]
选项与参数：
-v ：观察模式，可以列出更多的信息，包括镜像时的档案档名等；
-q ：与 -v  相反，安静模式，略过正常信息，仅显示错误讯息；
-r ：递归复制！可以针对『目录』来处理！很重要！
-u ：仅更新 (update)，若目标档案较新，则保留新档案不会覆盖；
-l ：复制链接文件的属性，而非链接的目标源文件内容；
-p ：复制时，连同属性 (permission) 也保存不变！
-g ：保存源文件的拥有群组；
-o ：保存源文件的拥有人；
-D ：保存源文件的装置属性 (device)
-t ：保存源文件的时间参数；
-I ：忽略更新时间 (mtime) 的属性，档案比对上会比较快速；
-z ：在数据传输时，加上压缩的参数！
-e ：使用的信道协议，例如使用 ssh 通道，则 -e ssh
-a ：相当于 -rlptgoD ，所以这个 -a 是最常用的参数了！
更多说明请参考 man rsync 的解说！
```

```bash
# 1. 将 /etc 的数据备份到 /tmp 底下：
[root@www ~]# rsync -av /etc /tmp
....(前面省略)....
sent 21979554 bytes  received 25934 bytes  4000997.82 bytes/sec
total size is 21877999  speedup is 0.99
[root@www ~]# ll -d /tmp/etc /etc
drwxr-xr-x. 106 root root 12288 Jul 26 16:10 /etc
drwxr-xr-x. 106 root root 12288 Jul 26 16:10 /tmp/etc <==瞧！两个目录一样！
# 第一次运作时会花比较久的时间，因为首次建立嘛！如果再次备份呢？

[root@www ~]# rsync -av /etc /tmp
sent 55716 bytes  received 240 bytes  111912.00 bytes/sec
total size is 21877999  speedup is 390.99
# 比较一下两次 rsync 的传输与接受数据量，你就会发现立刻就跑完了！
# 传输的数据也很少！因为再次比对，仅有差异的档案会被复制。

# 2. 利用 student 的身份登入 clientlinux.centos.vbird 将家目录复制到本机 /tmp
[root@www ~]# rsync -av -e ssh student@192.168.100.10:~ /tmp 
student@192.168.100.10's password:  <==输入对方主机的 student 密码
receiving file list ... done
student/
student/.bash_logout
....(中间省略)....
sent 110 bytes  received 697 bytes  124.15 bytes/sec
total size is 333  speedup is 0.41

[root@www ~]# ll -d /tmp/student
drwx------. 4 student student 4096 Jul 26 16:52 /tmp/student
# 瞧！这样就做好备份啦！很简单吧！
```



:question: 在 clientlinux.centos.vbird (192.168.100.10) 上面，使用 vbirdtsai 的身份建立一只脚本，这只脚本可以在每天的 2:00am 主动的以 rsync 配合 ssh 取得 www.centos.vbird (192.168.100.254) 的 /etc, /root, /home 三个目录的镜像到 clientlinux.centos.vbird 的 /backups/ 底下。

```bash
# 1. 在 clientlinux.centos.vbird 将公钥档复制给 www.centos.vbird 的 root
[vbirdtsia@clientlinux ~]$ scp ~/.ssh/id_rsa.pub root@192.168.100.254:~

# 2. 在 www.centos.vbird 上面用 root 建置好 authorized_keys
[root@www ~]# ls -ld id_rsa.pub .ssh
-rw-r--r--. 1 root root  416 Jul 26 16:59 id_rsa.pub <==有公钥档
drwx------. 2 root root 4096 Jul 25 11:44 .ssh       <==有 ssh 的相关目录

[root@www ~]# cat id_rsa.pub >> ~/.ssh/authorized_keys
[root@www ~]# chmod 644 ~/.ssh/authorized_keys

# 3. 在 clientlinux.centos.vbird 上面撰写 script 并测试执行：
[vbirdtsai@clientlinux ~]$ mkdir ~/bin ; vim ~/bin/backup_www.sh
#!/bin/bash
localdir=/backups
remotedir="/etc /root /home"
remoteip="192.168.100.254"

[ -d ${localdir} ] || mkdir ${localdir}
for dir in ${remotedir}
do
        rsync -av -e ssh root@${remoteip}:${dir} ${localdir}
done

[vbirdtsai@clientlinux ~]$ chmod 755 ~/bin/backup_www.sh
[vbirdtsai@clientlinux ~]$ ~/bin/backup_www.sh
# 上面在测试啦！第一次测试可能会失败，因为鸟哥忘记 /backups 需要 root
# 的权限才能够建立。所以，请您再以 root 的身份去 mkdir 及 setfacl 吧！

# 4. 建立 crontab 工作
[vbirdtsai@clientlinux ~]$ crontab -e
0 2 * * * /home/vbirdtsai/bin/backup_www.sh
```



























